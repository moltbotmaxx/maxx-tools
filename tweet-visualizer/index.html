<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tweet Visualizer</title>
  <style>
    :root {
      --bg: #000000;
      --panel: #16181c;
      --border: #2f3336;
      --text: #e7e9ea;
      --muted: #71767b;
      --blue: #1d9bf0;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #1f2937 0%, #000 46%);
      color: var(--text);
      font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      padding: 24px 16px 48px;
    }

    .app {
      max-width: 1280px;
      margin: 0 auto;
      display: grid;
      gap: 20px;
      grid-template-columns: 320px minmax(680px, 1fr);
      align-items: start;
    }

    .panel {
      background: rgba(22, 24, 28, 0.82);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 16px;
      backdrop-filter: blur(6px);
    }

    .panel h1 {
      margin: 0 0 14px;
      font-size: 1.2rem;
    }

    .field {
      display: grid;
      gap: 6px;
      margin-bottom: 12px;
    }

    .field label {
      font-size: 0.84rem;
      color: var(--muted);
    }

    .field input,
    .field textarea {
      width: 100%;
      background: #202327;
      color: var(--text);
      border: 1px solid #3a3d40;
      border-radius: 8px;
      padding: 9px 10px;
      font: inherit;
    }

    .field textarea {
      min-height: 160px;
      resize: vertical;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .range-wrap {
      margin-top: 8px;
    }

    .range-wrap output {
      color: var(--blue);
      font-size: 0.9rem;
      margin-left: 6px;
    }

    .actions {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 6px 0 10px;
    }

    .btn {
      border: 0;
      border-radius: 999px;
      padding: 9px 16px;
      background: var(--blue);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
    }

    .btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .btn--secondary {
      background: #2f3336;
      color: var(--text);
    }

    .status {
      font-size: 0.84rem;
      color: var(--muted);
    }

    .mode-select {
      width: 100%;
      background: #202327;
      color: var(--text);
      border: 1px solid #3a3d40;
      border-radius: 8px;
      padding: 9px 10px;
      font: inherit;
    }

    .toggle-row {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text);
      font-size: 0.9rem;
    }

    .toggle-row input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: var(--blue);
    }

    .preview-shell {
      display: flex;
      justify-content: center;
      overflow-x: auto;
      padding: 6px 0 0;
    }

    .preview-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 10px;
    }

    .preview-title {
      margin: 0;
      font-size: 0.95rem;
      color: var(--muted);
      font-weight: 600;
    }

    .tweet {
      width: 760px;
      max-width: 100%;
      background: transparent;
      border: 1px dashed var(--border);
      border-radius: 18px;
      padding: 16px;
    }

    .tweet-placeholder {
      color: var(--muted);
      text-align: center;
      padding: 52px 20px;
    }

    .clean-card {
      --card-bg: #000000;
      --card-border: #2f3336;
      --card-text: #e7e9ea;
      --card-muted: #71767b;
      --card-media-bg: #0f1419;
      --card-avatar-bg: #2f3336;
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 16px;
      padding: 14px;
      color: var(--card-text);
    }

    .clean-card--light {
      --card-bg: #ffffff;
      --card-border: #d7dce1;
      --card-text: #11181f;
      --card-muted: #536471;
      --card-media-bg: #eef3f7;
      --card-avatar-bg: #d7dce1;
    }

    .clean-head {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      margin-bottom: 10px;
    }

    .clean-avatar {
      width: 44px;
      height: 44px;
      border-radius: 999px;
      object-fit: cover;
      background: var(--card-avatar-bg);
      border: 1px solid var(--card-border);
    }

    .clean-meta {
      min-width: 0;
      padding-top: 1px;
    }

    .clean-name-row {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      margin-bottom: 2px;
    }

    .clean-name {
      font-size: 1rem;
      font-weight: 700;
    }

    .clean-handle {
      color: var(--card-muted);
      font-size: 0.95rem;
    }

    .clean-badge {
      width: 20px;
      height: 20px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 12px;
      line-height: 1;
      font-weight: 700;
    }

    .clean-badge--blue {
      background: #1d9bf0;
    }

    .clean-badge--business {
      background: #f6c343;
      color: #111;
    }

    .clean-badge--government {
      background: #8b98a5;
    }

    .clean-body {
      margin: 0;
      font-size: 1.18rem;
      line-height: 1.45;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .clean-time {
      margin-top: 8px;
      font-size: 0.9rem;
      color: var(--card-muted);
    }

    .clean-stats {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--card-border);
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
      color: var(--card-muted);
      font-size: 0.9rem;
    }

    .clean-stats b {
      color: var(--card-text);
      font-weight: 700;
      margin-right: 4px;
    }

    .clean-media-grid {
      margin-top: 12px;
      display: grid;
      gap: 8px;
      width: 100%;
      grid-template-columns: 1fr;
    }

    .clean-media-grid--2,
    .clean-media-grid--3,
    .clean-media-grid--4 {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .clean-media {
      margin-top: 0;
      width: 100%;
      border-radius: 14px;
      border: 1px solid var(--card-border);
      display: block;
      object-fit: cover;
      aspect-ratio: 1 / 1;
      background: var(--card-media-bg);
    }

    .clean-media-grid--1 .clean-media {
      aspect-ratio: 16 / 9;
      max-height: 420px;
    }

    .clean-media-grid--3 .clean-media:first-child {
      grid-column: 1 / -1;
      aspect-ratio: 16 / 9;
    }

    @media (max-width: 980px) {
      .app {
        grid-template-columns: 1fr;
      }

      .tweet {
        width: min(760px, 100%);
      }
    }
  </style>
</head>

<body>
  <main class="app">
    <section class="panel">
      <h1>Tweet Visualizer</h1>

      <div class="field">
        <label for="tweetUrl">Tweet URL</label>
        <input id="tweetUrl" value="" placeholder="https://x.com/user/status/1234567890123456789" />
      </div>

      <div class="actions">
        <div id="status" class="status">Paste a tweet URL to load it automatically.</div>
      </div>

      <div class="field">
        <label for="viewMode">View Mode</label>
        <select id="viewMode" class="mode-select">
          <option value="clean" selected>Clean (avatar + handle + body)</option>
          <option value="detailed">Detailed (time + metrics)</option>
        </select>
      </div>

      <div class="field">
        <label for="themeMode">Theme</label>
        <select id="themeMode" class="mode-select">
          <option value="dark" selected>Dark</option>
          <option value="light">White</option>
        </select>
      </div>

      <div class="field">
        <label>Reply text</label>
        <label class="toggle-row" for="stripReplyMentions">
          <input id="stripReplyMentions" type="checkbox" />
          Hide leading @mentions in thread replies
        </label>
      </div>

      <div class="field">
        <label for="width">Tweet Width</label>
        <div class="range-wrap">
          <input id="width" type="range" min="520" max="1120" value="760" />
          <output id="widthLabel">760px</output>
        </div>
      </div>
    </section>

    <section class="panel">
      <div class="preview-top">
        <h2 class="preview-title">Preview</h2>
        <button id="downloadBtn" class="btn btn--secondary" type="button" disabled>Download PNG</button>
      </div>
      <div class="preview-shell">
        <article class="tweet" id="tweet">
          <div id="embedContainer" class="tweet-placeholder">
            Paste a tweet URL to render a custom tweet card here.
          </div>
        </article>
      </div>
    </section>
  </main>

  <script>
    const $ = (id) => document.getElementById(id);
    let loadedTweet = null;
    let loadedCleanCardData = null;
    let latestLoadToken = 0;
    let widthReloadTimeout = null;

    function parseTweetUrl(urlString) {
      try {
        const url = new URL(urlString.trim());
        const match = url.pathname.match(/\/([^/]+)\/status(?:es)?\/(\d+)/i);
        if (!match) {
          return null;
        }
        return { handle: match[1], id: match[2], url: url.toString() };
      } catch {
        return null;
      }
    }

    function setStatus(message) {
      $("status").textContent = message;
    }

    function stripLeadingReplyMentions(text) {
      if (!text) {
        return "";
      }
      const stripped = text.replace(/^(?:\s*@[\w_]{1,15}[,\s]*)+/i, "").trimStart();
      return stripped || text;
    }

    function removeLinksFromText(text) {
      if (!text) {
        return "";
      }
      return text
        .replace(/https?:\/\/\S+/gi, "")
        .replace(/\bwww\.\S+/gi, "")
        .split(/\r?\n/)
        .map((line) => line.replace(/\s{2,}/g, " ").trimEnd())
        .join("\n")
        .trim();
    }

    function nextLoadToken() {
      latestLoadToken += 1;
      return latestLoadToken;
    }

    function isStaleToken(token) {
      return token !== latestLoadToken;
    }

    function updateDownloadButtonState() {
      const canDownload = Boolean(loadedCleanCardData);
      $("downloadBtn").disabled = !canDownload;
    }

    function setTweetWidth() {
      const width = Number($("width").value);
      $("tweet").style.width = `${width}px`;
      $("widthLabel").textContent = `${width}px`;
      return width;
    }


    function extractHandle(authorUrl) {
      try {
        const url = new URL(authorUrl);
        const handle = url.pathname.split("/").filter(Boolean)[0];
        return handle || null;
      } catch {
        return null;
      }
    }

    function getAvatarCandidates(handle) {
      if (!handle) {
        return ["https://abs.twimg.com/sticky/default_profile_images/default_profile_400x400.png"];
      }
      const normalized = encodeURIComponent(handle.replace(/^@/, ""));
      return [
        `https://unavatar.io/x/${normalized}`,
        `https://unavatar.io/twitter/${normalized}`,
        "https://abs.twimg.com/sticky/default_profile_images/default_profile_400x400.png"
      ];
    }

    function normalizeVerification(verification) {
      if (!verification || !verification.verified) {
        return { verified: false, type: null };
      }
      const type = verification.type || "blue";
      if (type === "business" || type === "government" || type === "blue") {
        return { verified: true, type };
      }
      return { verified: true, type: "blue" };
    }

    function createBadgeElement(verification) {
      if (!verification.verified) {
        return null;
      }
      const badge = document.createElement("span");
      badge.className = `clean-badge clean-badge--${verification.type}`;
      badge.textContent = "✓";
      return badge;
    }

    function drawVerificationBadge(ctx, x, y, verification) {
      if (!verification.verified) {
        return x;
      }

      const color = verification.type === "business"
        ? "#f6c343"
        : verification.type === "government"
          ? "#8b98a5"
          : "#1d9bf0";

      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x + 10, y + 10, 10, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = verification.type === "business" ? "#111" : "#fff";
      ctx.font = "700 14px Segoe UI, Roboto, Helvetica, Arial, sans-serif";
      ctx.fillText("✓", x + 5.5, y + 15);
      return x + 24;
    }

    function getThemePalette(themeMode) {
      if (themeMode === "light") {
        return {
          bg: "#ffffff",
          border: "#d7dce1",
          text: "#11181f",
          muted: "#536471",
          mediaBg: "#eef3f7",
          avatarBg: "#d7dce1"
        };
      }
      return {
        bg: "#000000",
        border: "#2f3336",
        text: "#e7e9ea",
        muted: "#71767b",
        mediaBg: "#0f1419",
        avatarBg: "#2f3336"
      };
    }

    function formatMetric(value) {
      if (value === null || value === undefined) {
        return "-";
      }
      const n = Number(value);
      if (!Number.isFinite(n)) {
        return String(value);
      }
      if (n >= 1000000) {
        return `${(n / 1000000).toFixed(1)}M`;
      }
      if (n >= 1000) {
        return `${(n / 1000).toFixed(1)}K`;
      }
      return String(n);
    }

    async function fetchTweetFromFxApi(parsedUrl) {
      const response = await fetch(`https://api.fxtwitter.com/status/${parsedUrl.id}`);
      if (!response.ok) {
        throw new Error("Could not fetch tweet metadata.");
      }

      const data = await response.json();
      if (data.code !== 200 || !data.tweet || !data.tweet.author) {
        throw new Error("Tweet metadata not available.");
      }

      const author = data.tweet.author;
      const handle = author.screen_name || parsedUrl.handle || "";
      let verification = { verified: false, type: null };

      if (handle) {
        try {
          const profileResponse = await fetch(`https://api.fxtwitter.com/${encodeURIComponent(handle)}`);
          if (profileResponse.ok) {
            const profileData = await profileResponse.json();
            verification = normalizeVerification(profileData?.user?.verification);
          }
        } catch {
          // Keep unverified fallback.
        }
      }

      const photoCandidates = (data.tweet.media?.photos || [])
        .map((photo) => photo.url)
        .filter(Boolean);
      const videoThumbCandidates = (data.tweet.media?.videos || [])
        .map((video) => video.thumbnail_url || video.url)
        .filter(Boolean);
      const mediaCandidates = [...photoCandidates, ...videoThumbCandidates];
      const tweetRawText = (data.tweet.raw_text?.text || "").trim();
      const tweetText = (data.tweet.text || "").trim();
      const bodyText = tweetRawText || tweetText;

      return {
        bodyText,
        displayName: author.name || handle || "Unknown",
        handleText: handle ? `@${handle}` : "@unknown",
        avatarCandidates: [author.avatar_url, ...getAvatarCandidates(handle)].filter(Boolean),
        mediaCandidates,
        verification,
        timestampLabel: data.tweet.created_at || "",
        metrics: {
          replies: data.tweet.replies,
          reposts: data.tweet.reposts ?? data.tweet.retweets,
          likes: data.tweet.likes,
          views: data.tweet.views
        }
      };
    }

    async function fetchTweetFromOembed(parsedUrl) {
      const endpoint = `https://publish.twitter.com/oembed?omit_script=1&dnt=true&url=${encodeURIComponent(parsedUrl.url)}`;
      const response = await fetch(endpoint);
      if (!response.ok) {
        throw new Error("Could not fetch tweet data.");
      }

      const data = await response.json();
      const parser = new DOMParser();
      const doc = parser.parseFromString(data.html || "", "text/html");
      const p = doc.querySelector("p");
      if (p) {
        p.querySelectorAll("br").forEach((br) => br.replaceWith("\n"));
      }
      const bodyText = (p?.textContent || "").trim();
      const handle = extractHandle(data.author_url || "") || parsedUrl.handle || "";
      return {
        bodyText,
        displayName: data.author_name || handle || "Unknown",
        handleText: handle ? `@${handle}` : "@unknown",
        avatarCandidates: getAvatarCandidates(handle),
        mediaCandidates: [],
        verification: { verified: false, type: null },
        timestampLabel: "",
        metrics: { replies: null, reposts: null, likes: null, views: null }
      };
    }

    async function loadCleanTweet(parsedUrl, loadToken = latestLoadToken) {
      const embedContainer = $("embedContainer");
      if (isStaleToken(loadToken)) {
        return;
      }
      setTweetWidth();
      loadedCleanCardData = null;
      updateDownloadButtonState();
      embedContainer.className = "";
      embedContainer.innerHTML = "";
      setStatus("Loading clean tweet...");

      try {
        let tweetData;
        try {
          tweetData = await fetchTweetFromFxApi(parsedUrl);
        } catch {
          tweetData = await fetchTweetFromOembed(parsedUrl);
        }
        if (isStaleToken(loadToken)) {
          return;
        }
        const {
          bodyText,
          displayName,
          handleText,
          avatarCandidates,
          mediaCandidates,
          verification,
          timestampLabel,
          metrics
        } = tweetData;
        const viewMode = $("viewMode").value;
        const themeMode = $("themeMode").value;
        const bodyAfterReplyStrip = $("stripReplyMentions").checked
          ? stripLeadingReplyMentions(bodyText)
          : bodyText;
        const finalBodyText = removeLinksFromText(bodyAfterReplyStrip);
        const defaultAvatar = "https://abs.twimg.com/sticky/default_profile_images/default_profile_400x400.png";
        let avatarUrl = avatarCandidates[0] || defaultAvatar;

        if (!finalBodyText) {
          throw new Error("Tweet text is not available for this URL.");
        }

        const card = document.createElement("article");
        card.className = `clean-card ${themeMode === "light" ? "clean-card--light" : ""}`.trim();

        const head = document.createElement("div");
        head.className = "clean-head";

        const avatar = document.createElement("img");
        avatar.className = "clean-avatar";
        avatar.src = avatarUrl;
        avatar.alt = `${displayName} avatar`;

        const meta = document.createElement("div");
        meta.className = "clean-meta";

        const nameRow = document.createElement("div");
        nameRow.className = "clean-name-row";

        const nameNode = document.createElement("span");
        nameNode.className = "clean-name";
        nameNode.textContent = displayName;

        nameRow.appendChild(nameNode);
        const badgeNode = createBadgeElement(verification);
        if (badgeNode) {
          nameRow.appendChild(badgeNode);
        }

        const handleNode = document.createElement("div");
        handleNode.className = "clean-handle";
        handleNode.textContent = handleText;

        meta.appendChild(nameRow);
        meta.appendChild(handleNode);

        head.appendChild(avatar);
        head.appendChild(meta);

        const body = document.createElement("p");
        body.className = "clean-body";
        body.textContent = finalBodyText;

        card.appendChild(head);
        card.appendChild(body);
        if (viewMode === "detailed") {
          const timeNode = document.createElement("div");
          timeNode.className = "clean-time";
          timeNode.textContent = timestampLabel || "Date unavailable";
          card.appendChild(timeNode);
        }
        const mediaUrls = Array.from(new Set((mediaCandidates || []).filter(Boolean))).slice(0, 4);
        const mediaCanvasSrcs = [];
        if (mediaUrls.length > 0) {
          const mediaGrid = document.createElement("div");
          mediaGrid.className = `clean-media-grid clean-media-grid--${mediaUrls.length}`;

          for (const candidate of mediaUrls) {
            const mediaImage = document.createElement("img");
            mediaImage.className = "clean-media";
            mediaImage.src = candidate;
            mediaImage.alt = "Tweet media";
            mediaGrid.appendChild(mediaImage);

            try {
              const canvasSrc = await fetchImageAsDataUrl(candidate);
              mediaCanvasSrcs.push(canvasSrc);
            } catch {
              mediaCanvasSrcs.push("");
            }
          }

          card.appendChild(mediaGrid);
        }
        if (viewMode === "detailed") {
          const stats = document.createElement("div");
          stats.className = "clean-stats";
          stats.innerHTML = `
            <span><b>${formatMetric(metrics?.replies)}</b>Replies</span>
            <span><b>${formatMetric(metrics?.reposts)}</b>Reposts</span>
            <span><b>${formatMetric(metrics?.likes)}</b>Likes</span>
            <span><b>${formatMetric(metrics?.views)}</b>Views</span>
          `;
          card.appendChild(stats);
        }
        embedContainer.appendChild(card);
        let avatarCanvasSrc = "";
        for (const candidate of avatarCandidates) {
          try {
            avatarCanvasSrc = await fetchImageAsDataUrl(candidate);
            avatarUrl = candidate;
            break;
          } catch {
            // Try the next candidate source.
          }
          if (isStaleToken(loadToken)) {
            return;
          }
        }
        if (isStaleToken(loadToken)) {
          return;
        }
        avatar.src = avatarUrl;
        loadedCleanCardData = {
          displayName,
          handleText,
          verification,
          mode: viewMode,
          themeMode,
          timestampLabel: timestampLabel || "",
          metrics: metrics || { replies: null, reposts: null, likes: null, views: null },
          bodyText: finalBodyText,
          avatarUrl,
          avatarCanvasSrc,
          mediaUrls,
          mediaCanvasSrcs
        };
        updateDownloadButtonState();
        setStatus("Clean tweet loaded.");
      } catch (error) {
        if (isStaleToken(loadToken)) {
          return;
        }
        embedContainer.className = "tweet-placeholder";
        embedContainer.textContent = "Could not load a clean version from this URL.";
        setStatus(error.message);
      }
    }

    function wrapTextLines(ctx, text, maxWidth) {
      const paragraphs = (text || "").split(/\r?\n/);
      const lines = [];

      for (const paragraph of paragraphs) {
        if (paragraph.length === 0) {
          lines.push("");
          continue;
        }

        const words = paragraph.split(/\s+/).filter(Boolean);
        let line = "";

        for (const word of words) {
          const candidate = line ? `${line} ${word}` : word;
          if (ctx.measureText(candidate).width <= maxWidth || !line) {
            line = candidate;
          } else {
            lines.push(line);
            line = word;
          }
        }

        if (line) {
          lines.push(line);
        }
      }

      return lines.length ? lines : [""];
    }

    async function loadAvatarImage(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.referrerPolicy = "no-referrer";
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = url;
      });
    }

    async function fetchImageAsDataUrl(url) {
      const response = await fetch(url, { mode: "cors" });
      if (!response.ok) {
        throw new Error("Could not fetch avatar image.");
      }
      const blob = await response.blob();
      return await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    async function downloadCleanPng() {
      if (!loadedCleanCardData) {
        setStatus("Load a clean tweet first, then download PNG.");
        return;
      }

      if (!loadedCleanCardData.avatarCanvasSrc) {
        try {
          loadedCleanCardData.avatarCanvasSrc = await fetchImageAsDataUrl(loadedCleanCardData.avatarUrl);
        } catch {
          // Keep going; avatar draw will fall back to a placeholder circle.
        }
      }

      if (loadedCleanCardData.mediaUrls?.length) {
        const canvasSrcs = loadedCleanCardData.mediaCanvasSrcs || [];
        for (let i = 0; i < loadedCleanCardData.mediaUrls.length; i += 1) {
          if (canvasSrcs[i]) {
            continue;
          }
          try {
            canvasSrcs[i] = await fetchImageAsDataUrl(loadedCleanCardData.mediaUrls[i]);
          } catch {
            canvasSrcs[i] = "";
          }
        }
        loadedCleanCardData.mediaCanvasSrcs = canvasSrcs;
      }

      const width = setTweetWidth();
      const scale = 2;
      const padding = 20;
      const avatarSize = 44;
      const topGap = 12;
      const lineHeight = 30;
      const palette = getThemePalette(loadedCleanCardData.themeMode || "dark");
      const isDetailed = loadedCleanCardData.mode === "detailed";
      const detailLineHeight = 24;
      const detailGap = 10;

      const measureCanvas = document.createElement("canvas");
      const measureCtx = measureCanvas.getContext("2d");
      if (!measureCtx) {
        setStatus("Could not initialize PNG export.");
        return;
      }
      measureCtx.font = "700 24px Segoe UI, Roboto, Helvetica, Arial, sans-serif";
      const bodyMaxWidth = width - padding * 2;
      const bodyLines = wrapTextLines(measureCtx, loadedCleanCardData.bodyText, bodyMaxWidth);
      const bodyHeight = Math.max(lineHeight, bodyLines.length * lineHeight);
      const timeHeight = isDetailed ? detailLineHeight : 0;
      const statsHeight = isDetailed ? detailLineHeight : 0;
      const detailHeight = isDetailed ? timeHeight + statsHeight + detailGap : 0;
      const rawMediaSources = (loadedCleanCardData.mediaUrls || [])
        .map((url, i) => loadedCleanCardData.mediaCanvasSrcs?.[i] || url)
        .filter(Boolean);
      const mediaSources = rawMediaSources.slice(0, 4);
      const mediaImages = [];
      for (const source of mediaSources) {
        try {
          mediaImages.push(await loadAvatarImage(source));
        } catch {
          mediaImages.push(null);
        }
      }

      const mediaCount = mediaSources.length;
      const mediaGap = 8;
      let mediaHeight = 0;
      let mediaFrames = [];
      if (mediaCount === 1) {
        const first = mediaImages[0];
        const ratio = first && first.naturalWidth > 0
          ? first.naturalHeight / first.naturalWidth
          : 0.56;
        const singleHeight = Math.max(180, Math.min(420, bodyMaxWidth * ratio));
        mediaHeight = singleHeight;
        mediaFrames = [{ x: 0, y: 0, w: bodyMaxWidth, h: singleHeight }];
      } else if (mediaCount === 2) {
        const cellW = (bodyMaxWidth - mediaGap) / 2;
        const cellH = Math.max(150, Math.min(320, cellW));
        mediaHeight = cellH;
        mediaFrames = [
          { x: 0, y: 0, w: cellW, h: cellH },
          { x: cellW + mediaGap, y: 0, w: cellW, h: cellH }
        ];
      } else if (mediaCount === 3) {
        const topH = Math.max(170, Math.min(300, bodyMaxWidth * 0.56));
        const cellW = (bodyMaxWidth - mediaGap) / 2;
        const bottomH = Math.max(140, Math.min(240, cellW));
        mediaHeight = topH + mediaGap + bottomH;
        mediaFrames = [
          { x: 0, y: 0, w: bodyMaxWidth, h: topH },
          { x: 0, y: topH + mediaGap, w: cellW, h: bottomH },
          { x: cellW + mediaGap, y: topH + mediaGap, w: cellW, h: bottomH }
        ];
      } else if (mediaCount >= 4) {
        const cellW = (bodyMaxWidth - mediaGap) / 2;
        const cellH = Math.max(140, Math.min(230, cellW));
        mediaHeight = cellH * 2 + mediaGap;
        mediaFrames = [
          { x: 0, y: 0, w: cellW, h: cellH },
          { x: cellW + mediaGap, y: 0, w: cellW, h: cellH },
          { x: 0, y: cellH + mediaGap, w: cellW, h: cellH },
          { x: cellW + mediaGap, y: cellH + mediaGap, w: cellW, h: cellH }
        ];
      }

      const height = padding + avatarSize + topGap + bodyHeight + detailHeight + (mediaHeight ? mediaHeight + 12 : 0) + padding;

      const canvas = document.createElement("canvas");
      canvas.width = Math.round(width * scale);
      canvas.height = Math.round(height * scale);
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        setStatus("Could not initialize PNG export.");
        return;
      }
      ctx.scale(scale, scale);

      ctx.fillStyle = palette.bg;
      ctx.fillRect(0, 0, width, height);

      try {
        const avatar = await loadAvatarImage(
          loadedCleanCardData.avatarCanvasSrc || loadedCleanCardData.avatarUrl
        );
        ctx.save();
        ctx.beginPath();
        ctx.arc(padding + avatarSize / 2, padding + avatarSize / 2, avatarSize / 2, 0, Math.PI * 2);
        ctx.closePath();
        ctx.clip();
        ctx.drawImage(avatar, padding, padding, avatarSize, avatarSize);
        ctx.restore();
      } catch {
        ctx.fillStyle = palette.avatarBg;
        ctx.beginPath();
        ctx.arc(padding + avatarSize / 2, padding + avatarSize / 2, avatarSize / 2, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = palette.text;
      ctx.font = "700 24px Segoe UI, Roboto, Helvetica, Arial, sans-serif";
      const nameX = padding + avatarSize + 12;
      const nameY = padding + 24;
      ctx.fillText(loadedCleanCardData.displayName || loadedCleanCardData.handleText, nameX, nameY);

      const nameWidth = ctx.measureText(loadedCleanCardData.displayName || loadedCleanCardData.handleText).width;
      const badgeX = drawVerificationBadge(ctx, nameX + nameWidth + 8, padding + 8, loadedCleanCardData.verification);

      ctx.fillStyle = palette.muted;
      ctx.font = "400 21px Segoe UI, Roboto, Helvetica, Arial, sans-serif";
      ctx.fillText(loadedCleanCardData.handleText, badgeX + 6, padding + 25);

      ctx.font = "400 24px Segoe UI, Roboto, Helvetica, Arial, sans-serif";
      ctx.fillStyle = palette.text;
      let y = padding + avatarSize + topGap + 24;
      for (const line of bodyLines) {
        ctx.fillText(line, padding, y);
        y += lineHeight;
      }

      if (isDetailed) {
        ctx.fillStyle = palette.muted;
        ctx.font = "400 19px Segoe UI, Roboto, Helvetica, Arial, sans-serif";
        ctx.fillText(loadedCleanCardData.timestampLabel || "Date unavailable", padding, y + 4);
        y += timeHeight;

        ctx.fillText(
          `${formatMetric(loadedCleanCardData.metrics?.replies)} Replies   ` +
          `${formatMetric(loadedCleanCardData.metrics?.reposts)} Reposts   ` +
          `${formatMetric(loadedCleanCardData.metrics?.likes)} Likes   ` +
          `${formatMetric(loadedCleanCardData.metrics?.views)} Views`,
          padding,
          y + 2
        );
        y += statsHeight + detailGap;
      }

      if (mediaHeight > 0) {
        const mediaX = padding;
        const mediaY = y + 4;
        const mediaW = bodyMaxWidth;
        const radius = 12;
        const drawRoundedMedia = (img, x, yy, w, h) => {
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(x + radius, yy);
          ctx.lineTo(x + w - radius, yy);
          ctx.quadraticCurveTo(x + w, yy, x + w, yy + radius);
          ctx.lineTo(x + w, yy + h - radius);
          ctx.quadraticCurveTo(x + w, yy + h, x + w - radius, yy + h);
          ctx.lineTo(x + radius, yy + h);
          ctx.quadraticCurveTo(x, yy + h, x, yy + h - radius);
          ctx.lineTo(x, yy + radius);
          ctx.quadraticCurveTo(x, yy, x + radius, yy);
          ctx.closePath();
          ctx.clip();
          if (img) {
            ctx.drawImage(img, x, yy, w, h);
          } else {
            ctx.fillStyle = palette.mediaBg;
            ctx.fillRect(x, yy, w, h);
          }
          ctx.restore();
        };

        for (let i = 0; i < mediaFrames.length; i += 1) {
          const frame = mediaFrames[i];
          const img = mediaImages[i] || null;
          drawRoundedMedia(
            img,
            mediaX + frame.x,
            mediaY + frame.y,
            frame.w,
            frame.h
          );
        }
      }

      const link = document.createElement("a");
      let pngUrl = "";
      try {
        pngUrl = canvas.toDataURL("image/png");
      } catch {
        setStatus("PNG export failed due browser image security restrictions.");
        return;
      }
      link.href = pngUrl;
      link.download = `tweet-clean-${Date.now()}.png`;
      link.click();
      setStatus("PNG downloaded.");
    }

    async function reloadCurrentTweet() {
      if (!loadedTweet) {
        return;
      }
      const loadToken = nextLoadToken();
      await loadCleanTweet(loadedTweet, loadToken);
    }

    async function onLoadTweet() {
      const parsed = parseTweetUrl($("tweetUrl").value);
      if (!parsed) {
        setStatus("Invalid tweet URL. Use a URL like https://x.com/user/status/...");
        return;
      }

      loadedTweet = { ...parsed, mode: $("viewMode").value };
      const loadToken = nextLoadToken();
      await loadCleanTweet(parsed, loadToken);
    }

    function onWidthInput() {
      setTweetWidth();
      if (!loadedTweet) {
        return;
      }
      if (widthReloadTimeout) {
        clearTimeout(widthReloadTimeout);
      }
      widthReloadTimeout = setTimeout(() => {
        reloadCurrentTweet();
      }, 180);
    }

    function onTweetUrlPaste() {
      setTimeout(() => {
        const parsed = parseTweetUrl($("tweetUrl").value);
        if (parsed) {
          onLoadTweet();
        } else {
          setStatus("Invalid tweet URL. Use a URL like https://x.com/user/status/...");
        }
      }, 0);
    }

    $("downloadBtn").addEventListener("click", downloadCleanPng);
    $("tweetUrl").addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        onLoadTweet();
      }
    });
    $("tweetUrl").addEventListener("paste", onTweetUrlPaste);
    $("stripReplyMentions").addEventListener("change", () => {
      if (loadedTweet) {
        reloadCurrentTweet();
      }
    });
    $("themeMode").addEventListener("change", () => {
      if (loadedTweet) {
        reloadCurrentTweet();
      }
    });
    $("viewMode").addEventListener("change", () => {
      updateDownloadButtonState();
      if (loadedTweet) {
        loadedTweet.mode = $("viewMode").value;
        reloadCurrentTweet();
      }
    });
    $("width").addEventListener("input", onWidthInput);
    setTweetWidth();
    updateDownloadButtonState();
  </script>
</body>

</html>
