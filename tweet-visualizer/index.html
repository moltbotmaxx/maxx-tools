<!doctype html>
<html lang="en" data-theme="light">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tweet Visualizer | Maxx Tools</title>
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üê¶</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../theme.css">
  <style>
    /* ‚îÄ‚îÄ App Shell ‚îÄ‚îÄ */
    body {
      font-family: 'Inter', var(--font-main);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .app-header {
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border-subtle);
      flex-shrink: 0;
      background: var(--bg-secondary);
    }

    .app-header__left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .app-header__icon {
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(29, 155, 240, 0.1);
      border-radius: 10px;
      font-size: 18px;
    }

    .app-header__title {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--text-primary);
      letter-spacing: -0.02em;
    }

    .app-header__version {
      font-size: 0.65rem;
      color: var(--text-muted);
      font-weight: 500;
    }

    .app-header__right {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .app-header__back {
      font-size: 0.78rem;
      font-weight: 600;
      color: var(--text-tertiary);
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 4px;
      transition: color var(--transition-fast);
    }

    .app-header__back:hover {
      color: var(--accent-primary);
    }

    /* ‚îÄ‚îÄ Main Layout ‚îÄ‚îÄ */
    .app-body {
      display: grid;
      grid-template-columns: 320px 1fr;
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }

    /* ‚îÄ‚îÄ Controls Panel ‚îÄ‚îÄ */
    .controls {
      background: var(--bg-secondary);
      border-right: 1px solid var(--border-subtle);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .controls__inner {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .controls__section {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .controls__section-label {
      font-size: 0.68rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
    }

    .controls__divider {
      height: 1px;
      background: var(--border-subtle);
      margin: 2px 0;
    }

    /* ‚îÄ‚îÄ Field ‚îÄ‚îÄ */
    .field {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .field__label {
      font-size: 0.72rem;
      font-weight: 600;
      color: var(--text-tertiary);
    }

    .field__input,
    .field__select {
      width: 100%;
      border: 1px solid var(--border-light);
      background: var(--bg-primary);
      color: var(--text-primary);
      border-radius: var(--radius-sm);
      padding: 9px 12px;
      font: inherit;
      font-size: 0.85rem;
      outline: none;
      transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
    }

    .field__input:focus,
    .field__select:focus {
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.12);
    }

    .field__input::placeholder {
      color: var(--text-muted);
      font-size: 0.82rem;
    }

    /* ‚îÄ‚îÄ Two-Column Grid ‚îÄ‚îÄ */
    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    /* ‚îÄ‚îÄ Slider Row ‚îÄ‚îÄ */
    .slider-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .slider-row input[type="range"] {
      flex: 1;
      accent-color: var(--accent-primary);
      height: 4px;
    }

    .slider-row__value {
      min-width: 52px;
      text-align: right;
      color: var(--accent-primary);
      font-weight: 700;
      font-size: 0.82rem;
      font-variant-numeric: tabular-nums;
    }

    .slider-row__value--sm {
      min-width: 38px;
      font-size: 0.78rem;
    }

    /* ‚îÄ‚îÄ Switch Row ‚îÄ‚îÄ */
    .switch-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.82rem;
      color: var(--text-secondary);
    }

    .switch-row input[type="checkbox"] {
      width: 15px;
      height: 15px;
      accent-color: var(--accent-primary);
      flex-shrink: 0;
    }

    /* ‚îÄ‚îÄ Status Bar ‚îÄ‚îÄ */
    .status-bar {
      padding: 8px 16px;
      border-top: 1px solid var(--border-subtle);
      font-size: 0.75rem;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
      background: var(--bg-secondary);
    }

    .status-bar--error {
      color: var(--accent-danger);
    }

    .status-bar--success {
      color: var(--accent-success);
    }

    .status-bar--loading {
      color: var(--accent-primary);
    }

    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: currentColor;
      flex-shrink: 0;
    }

    /* ‚îÄ‚îÄ Controls Footer (Download) ‚îÄ‚îÄ */
    .controls__footer {
      padding: 12px 16px;
      border-top: 1px solid var(--border-subtle);
      flex-shrink: 0;
      background: var(--bg-secondary);
    }

    .btn-download {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 10px 16px;
      border: none;
      border-radius: var(--radius-sm);
      background: var(--accent-primary);
      color: #FFFFFF;
      font-family: inherit;
      font-size: 0.82rem;
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition-fast);
      box-shadow: 0 4px 12px rgba(0, 122, 255, 0.2);
    }

    .btn-download:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(0, 122, 255, 0.3);
    }

    .btn-download:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-download svg {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
    }

    /* ‚îÄ‚îÄ Preview Canvas ‚îÄ‚îÄ */
    .preview {
      background: var(--bg-primary);
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding: 24px;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .preview__canvas {
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
      padding: 24px;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      max-width: 100%;
      width: fit-content;
    }

    .card-shell {
      width: 760px;
      max-width: 100%;
      transition: width 180ms ease;
    }


    .placeholder {
      border: 1px dashed var(--border-light);
      border-radius: var(--radius-md);
      padding: 48px 24px;
      text-align: center;
      color: var(--text-muted);
      background: var(--bg-primary);
      font-size: 0.88rem;
    }

    .placeholder strong {
      color: var(--text-secondary);
    }

    /* ‚îÄ‚îÄ Tweet Card CSS (kept for rendering & export) ‚îÄ‚îÄ */
    .tweet-card {
      --card-bg: #000000;
      --card-border: #2f3336;
      --card-text: #e7e9ea;
      --card-muted: #71767b;
      --card-media-bg: #0f1419;
      --card-avatar-bg: #2f3336;
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 18px;
      padding: 20px;
      color: var(--card-text);
      display: grid;
      gap: 0;
    }

    .tweet-card--light {
      --card-bg: #ffffff;
      --card-border: #d7dce1;
      --card-text: #11181f;
      --card-muted: #536471;
      --card-media-bg: #eef3f7;
      --card-avatar-bg: #d7dce1;
    }

    .tweet-head {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      margin-bottom: 10px;
    }

    .tweet-avatar {
      width: 44px;
      height: 44px;
      border-radius: 999px;
      object-fit: cover;
      background: var(--card-avatar-bg);
      border: 1px solid var(--card-border);
      flex: 0 0 auto;
    }

    .tweet-meta {
      min-width: 0;
      padding-top: 1px;
    }

    .name-row {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      margin-bottom: 1px;
    }

    .tweet-name {
      font-size: 1rem;
      font-weight: 800;
      color: var(--card-text);
      letter-spacing: -0.01em;
    }

    .tweet-handle {
      color: var(--card-muted);
      font-size: 0.95rem;
    }

    .verify-badge {
      width: 20px;
      height: 20px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      line-height: 1;
      font-weight: 700;
      color: #fff;
      flex: 0 0 auto;
    }

    .verify-badge--blue {
      background: #1d9bf0;
    }

    .verify-badge--business {
      background: #f6c343;
      color: #111;
    }

    .verify-badge--government {
      background: #8b98a5;
    }

    .tweet-body {
      margin: 0;
      color: var(--card-text);
      line-height: 1.45;
      font-size: 1.16rem;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .tweet-time {
      margin-top: 8px;
      font-size: 0.9rem;
      color: var(--card-muted);
    }

    .tweet-stats {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--card-border);
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
      color: var(--card-muted);
      font-size: 0.9rem;
    }

    .tweet-stats b {
      color: var(--card-text);
      font-weight: 800;
      margin-right: 4px;
    }

    .media-grid {
      margin-top: 12px;
      display: grid;
      gap: 8px;
      width: 100%;
      grid-template-columns: 1fr;
    }

    .media-grid--2,
    .media-grid--4 {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .media-grid--3 {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }

    .media-container {
      position: relative;
      overflow: hidden;
      border-radius: 14px;
      border: 1px solid var(--card-border);
      background: var(--card-media-bg);
      aspect-ratio: 1 / 1;
      cursor: grab;
    }

    .media-container:active {
      cursor: grabbing;
    }

    .media-item {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: cover;
      pointer-events: none;
      transform-origin: center center;
    }

    /* ‚îÄ‚îÄ Skeleton Shimmer ‚îÄ‚îÄ */
    .skeleton {
      position: relative;
      overflow: hidden;
    }

    .skeleton::after {
      content: "";
      position: absolute;
      inset: 0;
      transform: translateX(-100%);
      background: linear-gradient(90deg, transparent, rgba(0, 0, 0, 0.04), transparent);
      animation: shimmer 1.1s infinite;
    }

    @keyframes shimmer {
      100% {
        transform: translateX(100%);
      }
    }
  </style>
</head>

<body>
  <!-- ‚îÄ‚îÄ Header ‚îÄ‚îÄ -->
  <header class="app-header">
    <div class="app-header__left">
      <div class="app-header__icon">üê¶</div>
      <div>
        <div class="app-header__title">Tweet Visualizer</div>
        <div class="app-header__version">v2.0 ¬∑ maxx-tools</div>
      </div>
    </div>
    <div class="app-header__right">
      <a class="app-header__back" href="../">‚Üê Hub</a>
    </div>
  </header>

  <!-- ‚îÄ‚îÄ Body ‚îÄ‚îÄ -->
  <main class="app-body">

    <!-- ‚îÄ‚îÄ Controls ‚îÄ‚îÄ -->
    <aside class="controls">
      <div class="controls__inner">

        <!-- URL Input -->
        <div class="controls__section">
          <span class="controls__section-label">Tweet URL</span>
          <input id="tweetUrl" class="field__input" placeholder="https://x.com/user/status/..." autocomplete="off" />
        </div>

        <div class="controls__divider"></div>

        <!-- Card Settings -->
        <div class="controls__section">
          <span class="controls__section-label">Card Settings</span>
          <div class="grid-2">
            <div class="field">
              <label class="field__label" for="viewMode">Mode</label>
              <select id="viewMode" class="field__select">
                <option value="clean" selected>Clean</option>
                <option value="detailed">Detailed</option>
              </select>
            </div>
            <div class="field">
              <label class="field__label" for="themeMode">Theme</label>
              <select id="themeMode" class="field__select">
                <option value="dark" selected>Dark</option>
                <option value="light">Light</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Width -->
        <div class="field">
          <label class="field__label" for="width">Width</label>
          <div class="slider-row">
            <input id="width" type="range" min="520" max="1120" value="760" />
            <output id="widthValue" class="slider-row__value">760px</output>
          </div>
        </div>

        <!-- Text Cleanup -->
        <label class="switch-row" for="stripReplyMentions">
          <input id="stripReplyMentions" type="checkbox" checked />
          Strip @mentions
        </label>

      </div>

      <!-- Status -->
      <div id="status" class="status-bar" aria-live="polite">
        <span class="status-dot"></span>
        Ready
      </div>

      <!-- Download -->
      <div class="controls__footer">
        <button id="downloadBtn" class="btn-download" type="button" disabled>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
            <polyline points="7 10 12 15 17 10" />
            <line x1="12" y1="15" x2="12" y2="3" />
          </svg>
          Download PNG
        </button>
      </div>
    </aside>

    <!-- ‚îÄ‚îÄ Preview ‚îÄ‚îÄ -->
    <section class="preview" aria-label="Preview">
      <div class="preview__canvas">
        <div id="cardShell" class="card-shell">
          <div id="placeholder" class="placeholder">
            <strong>Ready.</strong> Paste a tweet URL to begin.
          </div>
        </div>
      </div>
    </section>

  </main>

  <script src="https://unpkg.com/html-to-image@1.11.11/dist/html-to-image.js"></script>
  <script>
    const el = {
      tweetUrl: document.getElementById("tweetUrl"),
      viewMode: document.getElementById("viewMode"),
      themeMode: document.getElementById("themeMode"),
      stripReplyMentions: document.getElementById("stripReplyMentions"),
      width: document.getElementById("width"),
      widthValue: document.getElementById("widthValue"),
      status: document.getElementById("status"),
      downloadBtn: document.getElementById("downloadBtn"),
      cardShell: document.getElementById("cardShell"),
      placeholder: document.getElementById("placeholder")
    };

    const state = {
      rawTweet: null,
      cardData: null,
      loading: false,
      width: 760,
      viewMode: "clean",
      themeMode: "dark",
      stripReplyMentions: true,
      activeToken: 0,
      abortController: null,
      fetchCache: new Map(),
      imageDataCache: new Map(),
      widthFrame: null,
      mediaPositions: [],
      mediaScales: [],
      selectedMediaIndex: 0,
      dragState: null
    };

    function setStatus(message, tone = "info") {
      el.status.innerHTML = `<span class="status-dot"></span> ${message}`;
      el.status.className = `status-bar status-bar--${tone}`;
    }

    function updateWidthUI() {
      el.widthValue.textContent = `${state.width}px`;
      el.cardShell.style.width = `${state.width}px`;
    }

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function ensureMediaPositions(mediaCount) {
      const prev = state.mediaPositions || [];
      state.mediaPositions = Array.from({ length: mediaCount }, (_, i) => {
        const existing = prev[i];
        if (!existing) {
          return { x: 50, y: 50 };
        }
        return {
          x: clamp(Number(existing.x) || 50, 0, 100),
          y: clamp(Number(existing.y) || 50, 0, 100)
        };
      });
      state.selectedMediaIndex = clamp(state.selectedMediaIndex, 0, Math.max(0, mediaCount - 1));
    }

    function ensureMediaScales(mediaCount) {
      const prev = state.mediaScales || [];
      state.mediaScales = Array.from({ length: mediaCount }, (_, i) => prev[i] ?? 1);
    }

    function syncMediaControlValues() {
      // No UI controls to sync ‚Äî drag + wheel handle everything
    }

    function setSelectedMediaIndex(index, rerender = true) {
      if (!state.cardData || !state.cardData.mediaUrls.length) {
        return;
      }
      state.selectedMediaIndex = clamp(index, 0, state.cardData.mediaUrls.length - 1);
      if (rerender) {
        renderPreview();
      }
    }

    function applySelectedMediaPosition(nextX, nextY, rerender = true) {
      if (!state.cardData || !state.cardData.mediaUrls.length) {
        return;
      }
      const idx = state.selectedMediaIndex;
      state.mediaPositions[idx] = {
        x: clamp(nextX, 0, 100),
        y: clamp(nextY, 0, 100)
      };
      if (state.cardData?.mediaPositions?.[idx]) {
        state.cardData.mediaPositions[idx] = { ...state.mediaPositions[idx] };
      }
      if (rerender) {
        renderPreview();
      } else {
        const activeImg = el.cardShell.querySelector(`.media-item[data-media-index="${idx}"]`);
        if (activeImg) {
          activeImg.style.objectPosition = `${state.mediaPositions[idx].x}% ${state.mediaPositions[idx].y}%`;
        }
      }
    }

    function parseTweetUrl(input) {
      try {
        const url = new URL(input.trim());
        const match = url.pathname.match(/\/([^/]+)\/status(?:es)?\/(\d+)/i);
        if (!match) {
          return null;
        }
        return {
          id: match[2],
          handle: match[1],
          canonicalUrl: `https://x.com/${match[1]}/status/${match[2]}`
        };
      } catch {
        return null;
      }
    }

    function dedupe(list) {
      return Array.from(new Set((list || []).filter(Boolean)));
    }

    function getAvatarCandidates(handle) {
      const fallback = "https://abs.twimg.com/sticky/default_profile_images/default_profile_400x400.png";
      if (!handle) {
        return [fallback];
      }
      const normalized = encodeURIComponent(handle.replace(/^@/, ""));
      return dedupe([
        `https://unavatar.io/x/${normalized}`,
        `https://unavatar.io/twitter/${normalized}`,
        fallback
      ]);
    }

    function normalizeVerification(verification) {
      if (!verification || !verification.verified) {
        return { verified: false, type: null };
      }
      if (["business", "government", "blue"].includes(verification.type)) {
        return { verified: true, type: verification.type };
      }
      return { verified: true, type: "blue" };
    }

    function stripLeadingReplyMentions(text) {
      if (!text) {
        return "";
      }
      const stripped = text.replace(/^(?:\s*@[_a-zA-Z0-9]{1,15}[,\s]*)+/i, "").trimStart();
      return stripped || text;
    }

    function removeLinksFromText(text) {
      if (!text) {
        return "";
      }
      return text
        .replace(/https?:\/\/\S+/gi, "")
        .replace(/\bwww\.\S+/gi, "")
        .split(/\r?\n/)
        .map((line) => line.replace(/\s{2,}/g, " ").trimEnd())
        .join("\n")
        .trim();
    }

    function formatMetric(value) {
      if (value === null || value === undefined || value === "") {
        return "-";
      }
      const n = Number(String(value).replace(/,/g, ""));
      if (!Number.isFinite(n)) {
        return String(value);
      }
      if (n >= 1000000) {
        return `${(n / 1000000).toFixed(1)}M`;
      }
      if (n >= 1000) {
        return `${(n / 1000).toFixed(1)}K`;
      }
      return `${n}`;
    }

    function formatTweetTimestamp(rawTimestamp) {
      if (!rawTimestamp) {
        return "";
      }
      const d = new Date(rawTimestamp);
      if (Number.isNaN(d.getTime())) {
        return rawTimestamp;
      }
      const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      const month = months[d.getUTCMonth()];
      const day = String(d.getUTCDate()).padStart(2, "0");
      const year = d.getUTCFullYear();
      const hh = String(d.getUTCHours()).padStart(2, "0");
      const mm = String(d.getUTCMinutes()).padStart(2, "0");
      const ss = String(d.getUTCSeconds()).padStart(2, "0");
      return `${month} ${day}, ${year} - ${hh}:${mm}:${ss}`;
    }

    function getThemePalette(themeMode) {
      if (themeMode === "light") {
        return {
          bg: "#ffffff",
          border: "#d7dce1",
          text: "#11181f",
          muted: "#536471",
          mediaBg: "#eef3f7",
          avatarBg: "#d7dce1"
        };
      }
      return {
        bg: "#000000",
        border: "#2f3336",
        text: "#e7e9ea",
        muted: "#71767b",
        mediaBg: "#0f1419",
        avatarBg: "#2f3336"
      };
    }

    function wrapTextLines(ctx, text, maxWidth) {
      const paragraphs = (text || "").split(/\r?\n/);
      const lines = [];

      for (const paragraph of paragraphs) {
        if (paragraph.length === 0) {
          lines.push("");
          continue;
        }

        const words = paragraph.split(/\s+/).filter(Boolean);
        let line = "";

        for (const word of words) {
          const candidate = line ? `${line} ${word}` : word;
          if (ctx.measureText(candidate).width <= maxWidth || !line) {
            line = candidate;
          } else {
            lines.push(line);
            line = word;
          }
        }

        if (line) {
          lines.push(line);
        }
      }

      return lines.length ? lines : [""];
    }

    function createVerifyBadge(verification) {
      if (!verification?.verified) {
        return null;
      }
      const badge = document.createElement("span");
      badge.className = `verify-badge verify-badge--${verification.type}`;
      badge.textContent = "‚úì";
      return badge;
    }

    function drawVerifyBadge(ctx, x, y, verification) {
      if (!verification?.verified) {
        return x;
      }
      const color = verification.type === "business"
        ? "#f6c343"
        : verification.type === "government"
          ? "#8b98a5"
          : "#1d9bf0";

      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x + 10, y + 10, 10, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = verification.type === "business" ? "#111" : "#fff";
      ctx.font = "700 14px Manrope, Segoe UI, sans-serif";
      ctx.fillText("‚úì", x + 5.5, y + 15);
      return x + 24;
    }

    function setLoading(active) {
      state.loading = active;
      el.downloadBtn.disabled = active || !state.cardData;
    }

    function updateSourceMeta() {
      // Removed ‚Äî no source meta display
    }

    function showPlaceholder(message, skeleton = false) {
      el.cardShell.innerHTML = `
        <div class="placeholder ${skeleton ? "skeleton" : ""}">
          ${message}
        </div>
      `;
    }

    function deriveCardData(rawTweet) {
      if (!rawTweet) {
        return null;
      }

      const mediaUrls = rawTweet.mediaUrls.slice(0, 4);
      ensureMediaPositions(mediaUrls.length);
      ensureMediaScales(mediaUrls.length);

      const textAfterMentions = state.stripReplyMentions
        ? stripLeadingReplyMentions(rawTweet.bodyRaw)
        : rawTweet.bodyRaw;

      const finalBodyText = removeLinksFromText(textAfterMentions);
      const bodyText = finalBodyText || rawTweet.bodyRaw || "";

      return {
        ...rawTweet,
        mediaUrls,
        mediaPositions: state.mediaPositions.map((p) => ({ x: p.x, y: p.y })),
        bodyText,
        mode: state.viewMode,
        themeMode: state.themeMode
      };
    }

    function renderPreview() {
      if (state.loading && !state.cardData) {
        showPlaceholder("Loading tweet data...", true);
        syncMediaControlValues();
        return;
      }

      if (!state.cardData) {
        showPlaceholder("<strong>Ready.</strong> Paste a tweet URL to begin.");
        syncMediaControlValues();
        return;
      }

      const data = state.cardData;
      const card = document.createElement("article");
      card.className = `tweet-card ${data.themeMode === "light" ? "tweet-card--light" : ""}`.trim();

      const head = document.createElement("div");
      head.className = "tweet-head";

      const avatar = document.createElement("img");
      avatar.className = "tweet-avatar";
      avatar.src = data.avatarUrl;
      avatar.alt = `${data.displayName} avatar`;

      const meta = document.createElement("div");
      meta.className = "tweet-meta";

      const nameRow = document.createElement("div");
      nameRow.className = "name-row";

      const nameNode = document.createElement("span");
      nameNode.className = "tweet-name";
      nameNode.textContent = data.displayName;
      nameRow.appendChild(nameNode);

      const badge = createVerifyBadge(data.verification);
      if (badge) {
        nameRow.appendChild(badge);
      }

      const handleNode = document.createElement("div");
      handleNode.className = "tweet-handle";
      handleNode.textContent = data.handleText;

      meta.appendChild(nameRow);
      meta.appendChild(handleNode);
      head.appendChild(avatar);
      head.appendChild(meta);

      const body = document.createElement("p");
      body.className = "tweet-body";
      body.textContent = data.bodyText;

      card.appendChild(head);
      card.appendChild(body);

      if (data.mediaUrls.length > 0) {
        const mediaGrid = document.createElement("div");
        const clipped = data.mediaUrls.slice(0, 4);
        mediaGrid.className = `media-grid media-grid--${clipped.length}`;

        clipped.forEach((url, i) => {
          const container = document.createElement("div");
          container.className = "media-container";
          container.dataset.mediaIndex = String(i);

          const img = document.createElement("img");
          img.className = "media-item";
          img.src = url;
          img.alt = "Tweet media";
          const pos = data.mediaPositions[i] || { x: 50, y: 50 };
          const scale = state.mediaScales[i] ?? 1;
          img.style.objectPosition = `${pos.x}% ${pos.y}%`;
          if (scale !== 1) {
            img.style.transform = `scale(${scale})`;
          }

          container.appendChild(img);
          container.addEventListener("pointerdown", onMediaPointerDown);
          container.addEventListener("wheel", onMediaWheel, { passive: false });
          mediaGrid.appendChild(container);
        });

        card.appendChild(mediaGrid);
      }

      if (data.mode === "detailed") {
        const stats = document.createElement("div");
        stats.className = "tweet-stats";
        stats.innerHTML = `
          <span><b>${formatMetric(data.metrics.replies)}</b>Replies</span>
          <span><b>${formatMetric(data.metrics.reposts)}</b>Reposts</span>
          <span><b>${formatMetric(data.metrics.likes)}</b>Likes</span>
          <span><b>${formatMetric(data.metrics.views)}</b>Views</span>
        `;
        card.appendChild(stats);
      }

      if (data.mode === "detailed") {
        const timeNode = document.createElement("div");
        timeNode.className = "tweet-time";
        timeNode.textContent = data.timestampLabel || "Date unavailable";
        card.appendChild(timeNode);
      }

      el.cardShell.innerHTML = "";
      el.cardShell.appendChild(card);
      syncMediaControlValues();
    }

    function toDataUrl(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    async function getDataUrlCached(url) {
      if (!url) {
        return null;
      }
      if (state.imageDataCache.has(url)) {
        return state.imageDataCache.get(url);
      }

      const promise = (async () => {
        try {
          const response = await fetch(url, { mode: "cors" });
          if (!response.ok) {
            return null;
          }
          const blob = await response.blob();
          return await toDataUrl(blob);
        } catch {
          return null;
        }
      })();

      state.imageDataCache.set(url, promise);
      return promise;
    }

    function loadImage(src) {
      return new Promise((resolve, reject) => {
        if (!src) {
          reject(new Error("Missing src"));
          return;
        }
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.referrerPolicy = "no-referrer";
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }

    function drawCoverImage(ctx, img, x, y, w, h, position = { x: 50, y: 50 }) {
      if (!img || img.naturalWidth <= 0 || img.naturalHeight <= 0) {
        return false;
      }

      const scale = Math.max(w / img.naturalWidth, h / img.naturalHeight);
      const drawW = img.naturalWidth * scale;
      const drawH = img.naturalHeight * scale;
      const freeX = w - drawW;
      const freeY = h - drawH;
      const px = clamp(position.x ?? 50, 0, 100) / 100;
      const py = clamp(position.y ?? 50, 0, 100) / 100;
      const drawX = x + freeX * px;
      const drawY = y + freeY * py;

      ctx.drawImage(img, drawX, drawY, drawW, drawH);
      return true;
    }

    async function resolveFirstImage(urls) {
      for (const url of urls || []) {
        const dataUrl = await getDataUrlCached(url);
        if (dataUrl) {
          return { displayUrl: url, dataUrl };
        }
      }
      return { displayUrl: (urls && urls[0]) || "", dataUrl: null };
    }

    async function prefetchAssets(rawTweet) {
      if (!rawTweet) {
        return;
      }
      const targets = [...rawTweet.avatarCandidates, ...rawTweet.mediaUrls.slice(0, 4)];
      await Promise.allSettled(targets.map((url) => getDataUrlCached(url)));
    }

    async function ensurePreviewUsesDataUrls(cardNode, data) {
      if (!cardNode || !data) {
        return;
      }

      const avatarNode = cardNode.querySelector(".tweet-avatar");
      if (avatarNode && data.avatarUrl) {
        const avatarData = data.avatarDataUrl || await getDataUrlCached(data.avatarUrl);
        if (avatarData) {
          avatarNode.src = avatarData;
        }
      }

      const mediaNodes = cardNode.querySelectorAll(".media-item");
      for (let i = 0; i < mediaNodes.length; i += 1) {
        const mediaUrl = data.mediaUrls[i];
        if (!mediaUrl) {
          continue;
        }
        const mediaData = await getDataUrlCached(mediaUrl);
        if (mediaData) {
          mediaNodes[i].src = mediaData;
        }
      }
    }

    async function fetchTweetFromFxApi(parsed, signal) {
      const statusResponse = await fetch(`https://api.fxtwitter.com/status/${parsed.id}`, { signal });
      if (!statusResponse.ok) {
        throw new Error("Could not fetch tweet metadata.");
      }

      const statusData = await statusResponse.json();
      if (statusData.code !== 200 || !statusData.tweet || !statusData.tweet.author) {
        throw new Error("Tweet metadata unavailable.");
      }

      const tweet = statusData.tweet;
      const author = tweet.author;
      const handle = author.screen_name || parsed.handle || "";
      let verification = { verified: false, type: null };

      if (handle) {
        try {
          const profileResponse = await fetch(`https://api.fxtwitter.com/${encodeURIComponent(handle)}`, { signal });
          if (profileResponse.ok) {
            const profileData = await profileResponse.json();
            verification = normalizeVerification(profileData?.user?.verification);
          }
        } catch {
          // Keep fallback verification.
        }
      }

      const photos = (tweet.media?.photos || []).map((p) => p.url).filter(Boolean);
      const videoThumbs = (tweet.media?.videos || []).map((v) => v.thumbnail_url || v.url).filter(Boolean);

      return {
        id: parsed.id,
        canonicalUrl: parsed.canonicalUrl,
        source: "fxtwitter",
        displayName: author.name || handle || "Unknown",
        handleText: handle ? `@${handle}` : "@unknown",
        verification,
        bodyRaw: (tweet.raw_text?.text || tweet.text || "").replace(/\r\n/g, "\n").trim(),
        timestampRaw: tweet.created_at || "",
        timestampLabel: formatTweetTimestamp(tweet.created_at || ""),
        metrics: {
          replies: tweet.replies ?? null,
          reposts: tweet.reposts ?? tweet.retweets ?? null,
          likes: tweet.likes ?? null,
          views: tweet.views ?? null
        },
        avatarCandidates: dedupe([author.avatar_url, ...getAvatarCandidates(handle)]),
        mediaUrls: dedupe([...photos, ...videoThumbs]).slice(0, 4)
      };
    }

    async function fetchTweetFromOembed(parsed, signal) {
      const response = await fetch(
        `https://publish.twitter.com/oembed?omit_script=1&dnt=true&url=${encodeURIComponent(parsed.canonicalUrl)}`,
        { signal }
      );

      if (!response.ok) {
        throw new Error("Could not fetch tweet via oEmbed.");
      }

      const data = await response.json();
      const parser = new DOMParser();
      const doc = parser.parseFromString(data.html || "", "text/html");
      const p = doc.querySelector("p");
      if (p) {
        p.querySelectorAll("br").forEach((br) => br.replaceWith("\n"));
      }
      const handle = (() => {
        try {
          const authorUrl = new URL(data.author_url || "");
          return authorUrl.pathname.split("/").filter(Boolean)[0] || parsed.handle || "";
        } catch {
          return parsed.handle || "";
        }
      })();

      return {
        id: parsed.id,
        canonicalUrl: parsed.canonicalUrl,
        source: "oembed",
        displayName: data.author_name || handle || "Unknown",
        handleText: handle ? `@${handle}` : "@unknown",
        verification: { verified: false, type: null },
        bodyRaw: (p?.textContent || "").replace(/\r\n/g, "\n").trim(),
        timestampRaw: "",
        timestampLabel: "",
        metrics: {
          replies: null,
          reposts: null,
          likes: null,
          views: null
        },
        avatarCandidates: getAvatarCandidates(handle),
        mediaUrls: []
      };
    }

    async function fetchAndNormalizeTweet(parsed, signal) {
      const cached = state.fetchCache.get(parsed.id);
      if (cached) {
        return cached;
      }

      let normalized;
      try {
        normalized = await fetchTweetFromFxApi(parsed, signal);
      } catch {
        normalized = await fetchTweetFromOembed(parsed, signal);
      }

      const avatarResolution = await resolveFirstImage(normalized.avatarCandidates);
      normalized.avatarUrl = avatarResolution.displayUrl;
      normalized.avatarDataUrl = avatarResolution.dataUrl;

      state.fetchCache.set(parsed.id, normalized);
      return normalized;
    }

    async function loadTweetFromInput() {
      const parsed = parseTweetUrl(el.tweetUrl.value);
      if (!parsed) {
        setStatus("Invalid URL ‚Äî use https://x.com/user/status/...", "error");
        return;
      }

      state.activeToken += 1;
      const token = state.activeToken;

      if (state.abortController) {
        state.abortController.abort();
      }
      state.abortController = new AbortController();

      setLoading(true);
      setStatus("Loading tweet‚Ä¶", "loading");
      if (!state.cardData) {
        showPlaceholder("Loading tweet data...", true);
      }

      try {
        const rawTweet = await fetchAndNormalizeTweet(parsed, state.abortController.signal);
        if (token !== state.activeToken) {
          return;
        }

        if (!state.rawTweet || state.rawTweet.id !== rawTweet.id) {
          state.selectedMediaIndex = 0;
          state.mediaPositions = [];
        }
        state.rawTweet = rawTweet;
        state.cardData = deriveCardData(rawTweet);
        updateSourceMeta(rawTweet);
        renderPreview();
        setStatus("Loaded", "success");
        setLoading(false);

        prefetchAssets(rawTweet);
      } catch (error) {
        if (error.name === "AbortError") {
          return;
        }
        state.rawTweet = null;
        state.cardData = null;
        setLoading(false);
        updateSourceMeta(null);
        showPlaceholder("<strong>Could not load this tweet.</strong> Check the URL and make sure the post is public.");
        setStatus(error.message || "Could not load tweet.", "error");
      }
    }

    function refreshCardFromState() {
      if (!state.rawTweet) {
        return;
      }
      state.cardData = deriveCardData(state.rawTweet);
      renderPreview();
      el.downloadBtn.disabled = false;
    }

    function onWidthInput() {
      state.width = Number(el.width.value);
      updateWidthUI();
      if (state.widthFrame) {
        cancelAnimationFrame(state.widthFrame);
      }
      state.widthFrame = requestAnimationFrame(() => {
        renderPreview();
      });
    }

    function onPasteAutoLoad() {
      setTimeout(() => {
        if (parseTweetUrl(el.tweetUrl.value)) {
          loadTweetFromInput();
        }
      }, 0);
    }

    function onMediaPointerDown(event) {
      if (!state.cardData) {
        return;
      }

      const container = event.currentTarget;
      const idx = Number(container.dataset.mediaIndex);
      if (!Number.isFinite(idx)) {
        return;
      }

      const img = container.querySelector(".media-item");
      if (!img) return;

      event.preventDefault();
      setSelectedMediaIndex(idx, false);

      const rect = container.getBoundingClientRect();
      const startX = event.clientX;
      const startY = event.clientY;
      const startPos = state.mediaPositions[idx] || { x: 50, y: 50 };
      const pointerId = event.pointerId;

      state.dragState = { pointerId, idx };
      if (container.setPointerCapture) {
        container.setPointerCapture(pointerId);
      }

      const onMove = (moveEvent) => {
        if (!state.dragState || moveEvent.pointerId !== pointerId) {
          return;
        }
        const dx = moveEvent.clientX - startX;
        const dy = moveEvent.clientY - startY;
        const nextX = clamp(startPos.x + (dx / Math.max(rect.width, 1)) * 100, 0, 100);
        const nextY = clamp(startPos.y + (dy / Math.max(rect.height, 1)) * 100, 0, 100);

        state.mediaPositions[idx] = { x: nextX, y: nextY };
        img.style.objectPosition = `${nextX}% ${nextY}%`;
      };

      const onEnd = (endEvent) => {
        if (endEvent.pointerId !== pointerId) {
          return;
        }
        window.removeEventListener("pointermove", onMove);
        window.removeEventListener("pointerup", onEnd);
        window.removeEventListener("pointercancel", onEnd);
        state.dragState = null;
        refreshCardFromState();
      };

      window.addEventListener("pointermove", onMove);
      window.addEventListener("pointerup", onEnd);
      window.addEventListener("pointercancel", onEnd);
    }

    function onMediaWheel(event) {
      event.preventDefault();
      const container = event.currentTarget;
      const idx = Number(container.dataset.mediaIndex);
      if (!Number.isFinite(idx)) return;

      const img = container.querySelector(".media-item");
      if (!img) return;

      const delta = event.deltaY > 0 ? -0.05 : 0.05;
      const current = state.mediaScales[idx] ?? 1;
      const next = clamp(current + delta, 1, 3);
      state.mediaScales[idx] = next;

      img.style.transform = `scale(${next})`;
    }

    async function downloadPng() {
      if (!state.cardData) {
        setStatus("Load a tweet first.", "error");
        return;
      }
      const cardNode = el.cardShell.querySelector(".tweet-card");
      if (!cardNode) {
        setStatus("Nothing to export.", "error");
        return;
      }

      if (!window.htmlToImage || !window.htmlToImage.toPng) {
        setStatus("PNG exporter failed to load.", "error");
        return;
      }

      el.downloadBtn.disabled = true;
      setStatus("Generating PNG‚Ä¶", "loading");

      try {
        await ensurePreviewUsesDataUrls(cardNode, state.cardData);
        const pngUrl = await window.htmlToImage.toPng(cardNode, {
          cacheBust: true,
          pixelRatio: 2
        });

        const link = document.createElement("a");
        link.href = pngUrl;
        link.download = `tweet-card-${Date.now()}.png`;
        link.click();
        setStatus("Done", "success");
      } catch (error) {
        setStatus("Export failed", "error");
      } finally {
        el.downloadBtn.disabled = state.loading || !state.cardData;
      }
    }

    function bindEvents() {
      el.tweetUrl.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          loadTweetFromInput();
        }
      });

      el.tweetUrl.addEventListener("paste", onPasteAutoLoad);

      el.viewMode.addEventListener("change", () => {
        state.viewMode = el.viewMode.value;
        refreshCardFromState();
      });

      el.themeMode.addEventListener("change", () => {
        state.themeMode = el.themeMode.value;
        refreshCardFromState();
      });

      el.stripReplyMentions.addEventListener("change", () => {
        state.stripReplyMentions = el.stripReplyMentions.checked;
        refreshCardFromState();
      });

      el.width.addEventListener("input", onWidthInput);

      el.downloadBtn.addEventListener("click", downloadPng);
    }

    function init() {
      state.width = Number(el.width.value);
      state.viewMode = el.viewMode.value;
      state.themeMode = el.themeMode.value;
      state.stripReplyMentions = el.stripReplyMentions.checked;
      updateWidthUI();
      bindEvents();
    }

    init();
  </script>
</body>

</html>