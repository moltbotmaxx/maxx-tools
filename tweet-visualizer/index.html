<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tweet Visualizer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&family=Sora:wght@500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --surface: #0c1117;
      --surface-soft: rgba(17, 24, 33, 0.78);
      --surface-edge: #273344;
      --text-main: #e6edf3;
      --text-muted: #93a4b8;
      --accent: #38bdf8;
      --accent-strong: #0ea5e9;
      --danger: #fb7185;
      --success: #22c55e;
      --radius-lg: 18px;
      --radius-md: 12px;
      --shadow: 0 24px 60px rgba(2, 6, 23, 0.45);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      color: var(--text-main);
      font-family: "Manrope", "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at 5% -10%, rgba(56, 189, 248, 0.2), transparent 42%),
        radial-gradient(circle at 100% 0%, rgba(14, 165, 233, 0.14), transparent 36%),
        linear-gradient(160deg, #04070d 0%, #0a111b 52%, #0c131e 100%);
      position: relative;
      overflow-x: hidden;
      padding: 28px 16px 48px;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background-image: linear-gradient(rgba(148, 163, 184, 0.06) 1px, transparent 1px),
        linear-gradient(90deg, rgba(148, 163, 184, 0.06) 1px, transparent 1px);
      background-size: 40px 40px;
      opacity: 0.2;
      pointer-events: none;
      z-index: -1;
    }

    .app {
      width: min(1320px, 100%);
      margin: 0 auto;
      display: grid;
      grid-template-columns: minmax(320px, 360px) minmax(0, 1fr);
      gap: 20px;
      align-items: start;
      animation: enter 420ms cubic-bezier(0.2, 0.9, 0.35, 1) both;
    }

    .panel {
      background: var(--surface-soft);
      border: 1px solid var(--surface-edge);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
    }

    .controls {
      padding: 18px;
      display: grid;
      gap: 14px;
    }

    .title {
      margin: 0;
      font-family: "Sora", "Manrope", sans-serif;
      font-size: 1.32rem;
      letter-spacing: -0.01em;
    }

    .subtitle {
      margin: 4px 0 0;
      color: var(--text-muted);
      font-size: 0.9rem;
      line-height: 1.45;
    }

    .field {
      display: grid;
      gap: 6px;
    }

    .field>label {
      color: var(--text-muted);
      font-size: 0.78rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .input,
    .select,
    .slider {
      width: 100%;
      border: 1px solid #324155;
      background: #111a25;
      color: var(--text-main);
      border-radius: var(--radius-md);
      padding: 10px 12px;
      font: inherit;
      outline: none;
      transition: border-color 160ms ease, box-shadow 160ms ease, background 160ms ease;
    }

    .input:focus,
    .select:focus,
    .slider:focus {
      border-color: var(--accent-strong);
      box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.2);
    }

    .slider-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .slider {
      padding: 0;
      accent-color: var(--accent);
      border: 0;
      background: transparent;
      box-shadow: none;
    }

    .slider-value {
      min-width: 68px;
      text-align: right;
      color: var(--accent);
      font-weight: 700;
      font-size: 0.9rem;
    }

    .slider-value--small {
      min-width: 48px;
      font-size: 0.82rem;
    }

    .grid-two {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .switch-row {
      display: flex;
      align-items: center;
      gap: 9px;
      color: var(--text-main);
      font-size: 0.88rem;
      padding: 6px 0;
    }

    .switch-row input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: var(--accent);
    }

    .subtle {
      margin: 2px 0 0;
      color: var(--text-muted);
      font-size: 0.78rem;
      line-height: 1.4;
    }

    .status {
      min-height: 20px;
      font-size: 0.84rem;
      color: var(--text-muted);
    }

    .status--error {
      color: var(--danger);
    }

    .status--success {
      color: var(--success);
    }

    .status--loading {
      color: var(--accent);
    }

    .meta-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid #314055;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.75rem;
      color: var(--text-muted);
      width: fit-content;
      background: rgba(17, 26, 37, 0.74);
    }

    .preview {
      padding: 14px;
      display: grid;
      gap: 10px;
    }

    .preview-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .preview-label {
      font-size: 0.82rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .btn {
      border: 0;
      border-radius: 999px;
      padding: 9px 14px;
      font: inherit;
      font-weight: 700;
      background: linear-gradient(135deg, #1f2937, #334155);
      color: var(--text-main);
      cursor: pointer;
      transition: transform 140ms ease, opacity 140ms ease, box-shadow 140ms ease;
      box-shadow: 0 10px 20px rgba(15, 23, 42, 0.35);
    }

    .btn:hover {
      transform: translateY(-1px);
    }

    .btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .preview-scroll {
      overflow: auto;
      padding: 6px;
      border-radius: 14px;
      border: 1px solid #2a3749;
      background: linear-gradient(180deg, rgba(10, 18, 28, 0.7), rgba(8, 13, 21, 0.36));
      min-height: 480px;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }

    .card-shell {
      width: 760px;
      max-width: 100%;
      transition: width 180ms ease;
    }

    .placeholder {
      border: 1px dashed #334155;
      border-radius: 18px;
      padding: 52px 22px;
      text-align: center;
      color: var(--text-muted);
      background: rgba(15, 23, 35, 0.4);
    }

    .placeholder strong {
      color: var(--text-main);
      font-weight: 700;
    }

    .tweet-card {
      --card-bg: #000000;
      --card-border: #2f3336;
      --card-text: #e7e9ea;
      --card-muted: #71767b;
      --card-media-bg: #0f1419;
      --card-avatar-bg: #2f3336;
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 18px;
      padding: 20px;
      color: var(--card-text);
      display: grid;
      gap: 0;
    }

    .tweet-card--light {
      --card-bg: #ffffff;
      --card-border: #d7dce1;
      --card-text: #11181f;
      --card-muted: #536471;
      --card-media-bg: #eef3f7;
      --card-avatar-bg: #d7dce1;
    }

    .tweet-head {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      margin-bottom: 10px;
    }

    .tweet-avatar {
      width: 44px;
      height: 44px;
      border-radius: 999px;
      object-fit: cover;
      background: var(--card-avatar-bg);
      border: 1px solid var(--card-border);
      flex: 0 0 auto;
    }

    .tweet-meta {
      min-width: 0;
      padding-top: 1px;
    }

    .name-row {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      margin-bottom: 1px;
    }

    .tweet-name {
      font-size: 1rem;
      font-weight: 800;
      color: var(--card-text);
      letter-spacing: -0.01em;
    }

    .tweet-handle {
      color: var(--card-muted);
      font-size: 0.95rem;
    }

    .verify-badge {
      width: 20px;
      height: 20px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      line-height: 1;
      font-weight: 700;
      color: #fff;
      flex: 0 0 auto;
    }

    .verify-badge--blue {
      background: #1d9bf0;
    }

    .verify-badge--business {
      background: #f6c343;
      color: #111;
    }

    .verify-badge--government {
      background: #8b98a5;
    }

    .tweet-body {
      margin: 0;
      color: var(--card-text);
      line-height: 1.45;
      font-size: 1.16rem;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .tweet-time {
      margin-top: 8px;
      font-size: 0.9rem;
      color: var(--card-muted);
    }

    .tweet-stats {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--card-border);
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
      color: var(--card-muted);
      font-size: 0.9rem;
    }

    .tweet-stats b {
      color: var(--card-text);
      font-weight: 800;
      margin-right: 4px;
    }

    .media-grid {
      margin-top: 12px;
      display: grid;
      gap: 8px;
      width: 100%;
      grid-template-columns: 1fr;
    }

    .media-grid--2,
    .media-grid--4 {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .media-grid--3 {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }

    .media-item {
      width: 100%;
      border-radius: 14px;
      border: 1px solid var(--card-border);
      display: block;
      object-fit: cover;
      aspect-ratio: 1 / 1;
      background: var(--card-media-bg);
      cursor: grab;
      user-select: none;
    }

    .media-item:active {
      cursor: grabbing;
    }

    .media-item--active {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.22);
    }

    .skeleton {
      position: relative;
      overflow: hidden;
    }

    .skeleton::after {
      content: "";
      position: absolute;
      inset: 0;
      transform: translateX(-100%);
      background: linear-gradient(90deg, transparent, rgba(148, 163, 184, 0.16), transparent);
      animation: shimmer 1.1s infinite;
    }

    @keyframes shimmer {
      100% {
        transform: translateX(100%);
      }
    }

    @keyframes enter {
      from {
        opacity: 0;
        transform: translateY(16px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @media (max-width: 980px) {
      .app {
        grid-template-columns: 1fr;
      }

      .controls {
        position: static;
      }

      .preview-scroll {
        min-height: 400px;
      }
    }
  </style>
</head>

<body>
  <main class="app">
    <section class="panel controls" aria-label="Controls">
      <header>
        <h1 class="title">Tweet Visualizer Studio</h1>
        <p class="subtitle">Paste a tweet URL. The card renders instantly in a custom format optimized for screenshots and PNG exports.</p>
      </header>

      <div class="field">
        <label for="tweetUrl">Tweet URL</label>
        <input id="tweetUrl" class="input" placeholder="https://x.com/user/status/1234567890123456789" autocomplete="off" />
      </div>

      <div class="grid-two">
        <div class="field">
          <label for="viewMode">Card Mode</label>
          <select id="viewMode" class="select">
            <option value="clean" selected>Clean</option>
            <option value="detailed">Detailed</option>
          </select>
        </div>

        <div class="field">
          <label for="themeMode">Theme</label>
          <select id="themeMode" class="select">
            <option value="dark" selected>Dark</option>
            <option value="light">White</option>
          </select>
        </div>
      </div>

      <div class="field">
        <label for="width">Card Width</label>
        <div class="slider-row">
          <input id="width" class="slider" type="range" min="520" max="1120" value="760" />
          <output id="widthValue" class="slider-value">760px</output>
        </div>
      </div>

      <div class="field">
        <label>Text Cleanup</label>
        <label class="switch-row" for="stripReplyMentions">
          <input id="stripReplyMentions" type="checkbox" checked />
          Hide leading @mentions from reply chains
        </label>
      </div>

      <div id="mediaControls" class="field" hidden>
        <label>Media Position</label>
        <div class="grid-two">
          <div class="field">
            <label for="mediaIndex">Image</label>
            <select id="mediaIndex" class="select"></select>
          </div>
          <div class="field">
            <label for="mediaPosX">Horizontal</label>
            <div class="slider-row">
              <input id="mediaPosX" class="slider" type="range" min="0" max="100" step="1" value="50" />
              <output id="mediaPosXValue" class="slider-value slider-value--small">50%</output>
            </div>
          </div>
        </div>
        <div class="field">
          <label for="mediaPosY">Vertical</label>
          <div class="slider-row">
            <input id="mediaPosY" class="slider" type="range" min="0" max="100" step="1" value="50" />
            <output id="mediaPosYValue" class="slider-value slider-value--small">50%</output>
          </div>
        </div>
        <p class="subtle">Drag directly on an image to reposition faster.</p>
      </div>

      <div id="status" class="status" aria-live="polite">Paste a tweet URL to start.</div>
      <div id="sourceMeta" class="meta-pill" hidden></div>
    </section>

    <section class="panel preview" aria-label="Preview">
      <div class="preview-head">
        <div class="preview-label">Preview</div>
        <button id="downloadBtn" class="btn" type="button" disabled>Download PNG</button>
      </div>
      <div class="preview-scroll">
        <div id="cardShell" class="card-shell">
          <div id="placeholder" class="placeholder">
            <strong>Ready.</strong> Paste a tweet URL and the card will load automatically.
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
    const el = {
      tweetUrl: document.getElementById("tweetUrl"),
      viewMode: document.getElementById("viewMode"),
      themeMode: document.getElementById("themeMode"),
      stripReplyMentions: document.getElementById("stripReplyMentions"),
      width: document.getElementById("width"),
      widthValue: document.getElementById("widthValue"),
      mediaControls: document.getElementById("mediaControls"),
      mediaIndex: document.getElementById("mediaIndex"),
      mediaPosX: document.getElementById("mediaPosX"),
      mediaPosY: document.getElementById("mediaPosY"),
      mediaPosXValue: document.getElementById("mediaPosXValue"),
      mediaPosYValue: document.getElementById("mediaPosYValue"),
      status: document.getElementById("status"),
      sourceMeta: document.getElementById("sourceMeta"),
      downloadBtn: document.getElementById("downloadBtn"),
      cardShell: document.getElementById("cardShell"),
      placeholder: document.getElementById("placeholder")
    };

    const state = {
      rawTweet: null,
      cardData: null,
      loading: false,
      width: 760,
      viewMode: "clean",
      themeMode: "dark",
      stripReplyMentions: true,
      activeToken: 0,
      abortController: null,
      fetchCache: new Map(),
      imageDataCache: new Map(),
      widthFrame: null,
      mediaPositions: [],
      selectedMediaIndex: 0,
      dragState: null
    };

    function setStatus(message, tone = "info") {
      el.status.textContent = message;
      el.status.className = `status status--${tone}`;
    }

    function updateWidthUI() {
      el.widthValue.textContent = `${state.width}px`;
      el.cardShell.style.width = `${state.width}px`;
    }

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function ensureMediaPositions(mediaCount) {
      const prev = state.mediaPositions || [];
      state.mediaPositions = Array.from({ length: mediaCount }, (_, i) => {
        const existing = prev[i];
        if (!existing) {
          return { x: 50, y: 50 };
        }
        return {
          x: clamp(Number(existing.x) || 50, 0, 100),
          y: clamp(Number(existing.y) || 50, 0, 100)
        };
      });
      state.selectedMediaIndex = clamp(state.selectedMediaIndex, 0, Math.max(0, mediaCount - 1));
    }

    function syncMediaControlValues() {
      if (!state.cardData || !state.cardData.mediaUrls.length) {
        el.mediaControls.hidden = true;
        return;
      }

      const mediaCount = state.cardData.mediaUrls.length;
      el.mediaControls.hidden = false;

      if (el.mediaIndex.options.length !== mediaCount) {
        el.mediaIndex.innerHTML = "";
        for (let i = 0; i < mediaCount; i += 1) {
          const option = document.createElement("option");
          option.value = String(i);
          option.textContent = `Image ${i + 1}`;
          el.mediaIndex.appendChild(option);
        }
      }

      const idx = clamp(state.selectedMediaIndex, 0, mediaCount - 1);
      state.selectedMediaIndex = idx;
      el.mediaIndex.value = String(idx);

      const pos = state.mediaPositions[idx] || { x: 50, y: 50 };
      el.mediaPosX.value = String(Math.round(pos.x));
      el.mediaPosY.value = String(Math.round(pos.y));
      el.mediaPosXValue.textContent = `${Math.round(pos.x)}%`;
      el.mediaPosYValue.textContent = `${Math.round(pos.y)}%`;
    }

    function setSelectedMediaIndex(index, rerender = true) {
      if (!state.cardData || !state.cardData.mediaUrls.length) {
        return;
      }
      state.selectedMediaIndex = clamp(index, 0, state.cardData.mediaUrls.length - 1);
      syncMediaControlValues();
      if (rerender) {
        renderPreview();
      }
    }

    function applySelectedMediaPosition(nextX, nextY, rerender = true) {
      if (!state.cardData || !state.cardData.mediaUrls.length) {
        return;
      }
      const idx = state.selectedMediaIndex;
      state.mediaPositions[idx] = {
        x: clamp(nextX, 0, 100),
        y: clamp(nextY, 0, 100)
      };
      if (state.cardData?.mediaPositions?.[idx]) {
        state.cardData.mediaPositions[idx] = { ...state.mediaPositions[idx] };
      }
      syncMediaControlValues();
      if (rerender) {
        renderPreview();
      } else {
        const activeImg = el.cardShell.querySelector(`.media-item[data-media-index=\"${idx}\"]`);
        if (activeImg) {
          activeImg.style.objectPosition = `${state.mediaPositions[idx].x}% ${state.mediaPositions[idx].y}%`;
        }
      }
    }

    function parseTweetUrl(input) {
      try {
        const url = new URL(input.trim());
        const match = url.pathname.match(/\/([^/]+)\/status(?:es)?\/(\d+)/i);
        if (!match) {
          return null;
        }
        return {
          id: match[2],
          handle: match[1],
          canonicalUrl: `https://x.com/${match[1]}/status/${match[2]}`
        };
      } catch {
        return null;
      }
    }

    function dedupe(list) {
      return Array.from(new Set((list || []).filter(Boolean)));
    }

    function getAvatarCandidates(handle) {
      const fallback = "https://abs.twimg.com/sticky/default_profile_images/default_profile_400x400.png";
      if (!handle) {
        return [fallback];
      }
      const normalized = encodeURIComponent(handle.replace(/^@/, ""));
      return dedupe([
        `https://unavatar.io/x/${normalized}`,
        `https://unavatar.io/twitter/${normalized}`,
        fallback
      ]);
    }

    function normalizeVerification(verification) {
      if (!verification || !verification.verified) {
        return { verified: false, type: null };
      }
      if (["business", "government", "blue"].includes(verification.type)) {
        return { verified: true, type: verification.type };
      }
      return { verified: true, type: "blue" };
    }

    function stripLeadingReplyMentions(text) {
      if (!text) {
        return "";
      }
      const stripped = text.replace(/^(?:\s*@[_a-zA-Z0-9]{1,15}[,\s]*)+/i, "").trimStart();
      return stripped || text;
    }

    function removeLinksFromText(text) {
      if (!text) {
        return "";
      }
      return text
        .replace(/https?:\/\/\S+/gi, "")
        .replace(/\bwww\.\S+/gi, "")
        .split(/\r?\n/)
        .map((line) => line.replace(/\s{2,}/g, " ").trimEnd())
        .join("\n")
        .trim();
    }

    function formatMetric(value) {
      if (value === null || value === undefined || value === "") {
        return "-";
      }
      const n = Number(String(value).replace(/,/g, ""));
      if (!Number.isFinite(n)) {
        return String(value);
      }
      if (n >= 1000000) {
        return `${(n / 1000000).toFixed(1)}M`;
      }
      if (n >= 1000) {
        return `${(n / 1000).toFixed(1)}K`;
      }
      return `${n}`;
    }

    function formatTweetTimestamp(rawTimestamp) {
      if (!rawTimestamp) {
        return "";
      }
      const d = new Date(rawTimestamp);
      if (Number.isNaN(d.getTime())) {
        return rawTimestamp;
      }
      const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      const month = months[d.getUTCMonth()];
      const day = String(d.getUTCDate()).padStart(2, "0");
      const year = d.getUTCFullYear();
      const hh = String(d.getUTCHours()).padStart(2, "0");
      const mm = String(d.getUTCMinutes()).padStart(2, "0");
      const ss = String(d.getUTCSeconds()).padStart(2, "0");
      return `${month} ${day}, ${year} - ${hh}:${mm}:${ss}`;
    }

    function getThemePalette(themeMode) {
      if (themeMode === "light") {
        return {
          bg: "#ffffff",
          border: "#d7dce1",
          text: "#11181f",
          muted: "#536471",
          mediaBg: "#eef3f7",
          avatarBg: "#d7dce1"
        };
      }
      return {
        bg: "#000000",
        border: "#2f3336",
        text: "#e7e9ea",
        muted: "#71767b",
        mediaBg: "#0f1419",
        avatarBg: "#2f3336"
      };
    }

    function wrapTextLines(ctx, text, maxWidth) {
      const paragraphs = (text || "").split(/\r?\n/);
      const lines = [];

      for (const paragraph of paragraphs) {
        if (paragraph.length === 0) {
          lines.push("");
          continue;
        }

        const words = paragraph.split(/\s+/).filter(Boolean);
        let line = "";

        for (const word of words) {
          const candidate = line ? `${line} ${word}` : word;
          if (ctx.measureText(candidate).width <= maxWidth || !line) {
            line = candidate;
          } else {
            lines.push(line);
            line = word;
          }
        }

        if (line) {
          lines.push(line);
        }
      }

      return lines.length ? lines : [""];
    }

    function createVerifyBadge(verification) {
      if (!verification?.verified) {
        return null;
      }
      const badge = document.createElement("span");
      badge.className = `verify-badge verify-badge--${verification.type}`;
      badge.textContent = "✓";
      return badge;
    }

    function drawVerifyBadge(ctx, x, y, verification) {
      if (!verification?.verified) {
        return x;
      }
      const color = verification.type === "business"
        ? "#f6c343"
        : verification.type === "government"
          ? "#8b98a5"
          : "#1d9bf0";

      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x + 10, y + 10, 10, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = verification.type === "business" ? "#111" : "#fff";
      ctx.font = "700 14px Manrope, Segoe UI, sans-serif";
      ctx.fillText("✓", x + 5.5, y + 15);
      return x + 24;
    }

    function setLoading(active) {
      state.loading = active;
      el.downloadBtn.disabled = active || !state.cardData;
    }

    function updateSourceMeta(rawTweet) {
      if (!rawTweet) {
        el.sourceMeta.hidden = true;
        return;
      }
      const mediaCount = rawTweet.mediaUrls.length;
      const modeLabel = rawTweet.source === "fxtwitter" ? "FX API" : "oEmbed fallback";
      el.sourceMeta.textContent = `${modeLabel} • ${mediaCount} media • ${rawTweet.handleText}`;
      el.sourceMeta.hidden = false;
    }

    function showPlaceholder(message, skeleton = false) {
      el.cardShell.innerHTML = `
        <div class="placeholder ${skeleton ? "skeleton" : ""}">
          ${message}
        </div>
      `;
    }

    function deriveCardData(rawTweet) {
      if (!rawTweet) {
        return null;
      }

      const mediaUrls = rawTweet.mediaUrls.slice(0, 4);
      ensureMediaPositions(mediaUrls.length);

      const textAfterMentions = state.stripReplyMentions
        ? stripLeadingReplyMentions(rawTweet.bodyRaw)
        : rawTweet.bodyRaw;

      const finalBodyText = removeLinksFromText(textAfterMentions);
      const bodyText = finalBodyText || rawTweet.bodyRaw || "";

      return {
        ...rawTweet,
        mediaUrls,
        mediaPositions: state.mediaPositions.map((p) => ({ x: p.x, y: p.y })),
        bodyText,
        mode: state.viewMode,
        themeMode: state.themeMode
      };
    }

    function renderPreview() {
      if (state.loading && !state.cardData) {
        showPlaceholder("Loading tweet data...", true);
        syncMediaControlValues();
        return;
      }

      if (!state.cardData) {
        showPlaceholder("<strong>Ready.</strong> Paste a tweet URL and the card will load automatically.");
        syncMediaControlValues();
        return;
      }

      const data = state.cardData;
      const card = document.createElement("article");
      card.className = `tweet-card ${data.themeMode === "light" ? "tweet-card--light" : ""}`.trim();

      const head = document.createElement("div");
      head.className = "tweet-head";

      const avatar = document.createElement("img");
      avatar.className = "tweet-avatar";
      avatar.src = data.avatarUrl;
      avatar.alt = `${data.displayName} avatar`;

      const meta = document.createElement("div");
      meta.className = "tweet-meta";

      const nameRow = document.createElement("div");
      nameRow.className = "name-row";

      const nameNode = document.createElement("span");
      nameNode.className = "tweet-name";
      nameNode.textContent = data.displayName;
      nameRow.appendChild(nameNode);

      const badge = createVerifyBadge(data.verification);
      if (badge) {
        nameRow.appendChild(badge);
      }

      const handleNode = document.createElement("div");
      handleNode.className = "tweet-handle";
      handleNode.textContent = data.handleText;

      meta.appendChild(nameRow);
      meta.appendChild(handleNode);
      head.appendChild(avatar);
      head.appendChild(meta);

      const body = document.createElement("p");
      body.className = "tweet-body";
      body.textContent = data.bodyText;

      card.appendChild(head);
      card.appendChild(body);

      if (data.mediaUrls.length > 0) {
        const mediaGrid = document.createElement("div");
        const clipped = data.mediaUrls.slice(0, 4);
        mediaGrid.className = `media-grid media-grid--${clipped.length}`;

        clipped.forEach((url, i) => {
          const img = document.createElement("img");
          img.className = "media-item";
          if (i === state.selectedMediaIndex) {
            img.classList.add("media-item--active");
          }
          img.src = url;
          img.alt = "Tweet media";
          const pos = data.mediaPositions[i] || { x: 50, y: 50 };
          img.style.objectPosition = `${pos.x}% ${pos.y}%`;
          img.dataset.mediaIndex = String(i);
          img.addEventListener("pointerdown", onMediaPointerDown);
          mediaGrid.appendChild(img);
        });

        card.appendChild(mediaGrid);
      }

      if (data.mode === "detailed") {
        const stats = document.createElement("div");
        stats.className = "tweet-stats";
        stats.innerHTML = `
          <span><b>${formatMetric(data.metrics.replies)}</b>Replies</span>
          <span><b>${formatMetric(data.metrics.reposts)}</b>Reposts</span>
          <span><b>${formatMetric(data.metrics.likes)}</b>Likes</span>
          <span><b>${formatMetric(data.metrics.views)}</b>Views</span>
        `;
        card.appendChild(stats);
      }

      if (data.mode === "detailed") {
        const timeNode = document.createElement("div");
        timeNode.className = "tweet-time";
        timeNode.textContent = data.timestampLabel || "Date unavailable";
        card.appendChild(timeNode);
      }

      el.cardShell.innerHTML = "";
      el.cardShell.appendChild(card);
      syncMediaControlValues();
    }

    function toDataUrl(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    async function getDataUrlCached(url) {
      if (!url) {
        return null;
      }
      if (state.imageDataCache.has(url)) {
        return state.imageDataCache.get(url);
      }

      const promise = (async () => {
        try {
          const response = await fetch(url, { mode: "cors" });
          if (!response.ok) {
            return null;
          }
          const blob = await response.blob();
          return await toDataUrl(blob);
        } catch {
          return null;
        }
      })();

      state.imageDataCache.set(url, promise);
      return promise;
    }

    function loadImage(src) {
      return new Promise((resolve, reject) => {
        if (!src) {
          reject(new Error("Missing src"));
          return;
        }
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.referrerPolicy = "no-referrer";
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }

    function drawCoverImage(ctx, img, x, y, w, h, position = { x: 50, y: 50 }) {
      if (!img || img.naturalWidth <= 0 || img.naturalHeight <= 0) {
        return false;
      }

      const scale = Math.max(w / img.naturalWidth, h / img.naturalHeight);
      const drawW = img.naturalWidth * scale;
      const drawH = img.naturalHeight * scale;
      const freeX = w - drawW;
      const freeY = h - drawH;
      const px = clamp(position.x ?? 50, 0, 100) / 100;
      const py = clamp(position.y ?? 50, 0, 100) / 100;
      const drawX = x + freeX * px;
      const drawY = y + freeY * py;

      ctx.drawImage(img, drawX, drawY, drawW, drawH);
      return true;
    }

    async function resolveFirstImage(urls) {
      for (const url of urls || []) {
        const dataUrl = await getDataUrlCached(url);
        if (dataUrl) {
          return { displayUrl: url, dataUrl };
        }
      }
      return { displayUrl: (urls && urls[0]) || "", dataUrl: null };
    }

    async function prefetchAssets(rawTweet) {
      if (!rawTweet) {
        return;
      }
      const targets = [...rawTweet.avatarCandidates, ...rawTweet.mediaUrls.slice(0, 4)];
      await Promise.allSettled(targets.map((url) => getDataUrlCached(url)));
    }

    async function fetchTweetFromFxApi(parsed, signal) {
      const statusResponse = await fetch(`https://api.fxtwitter.com/status/${parsed.id}`, { signal });
      if (!statusResponse.ok) {
        throw new Error("Could not fetch tweet metadata.");
      }

      const statusData = await statusResponse.json();
      if (statusData.code !== 200 || !statusData.tweet || !statusData.tweet.author) {
        throw new Error("Tweet metadata unavailable.");
      }

      const tweet = statusData.tweet;
      const author = tweet.author;
      const handle = author.screen_name || parsed.handle || "";
      let verification = { verified: false, type: null };

      if (handle) {
        try {
          const profileResponse = await fetch(`https://api.fxtwitter.com/${encodeURIComponent(handle)}`, { signal });
          if (profileResponse.ok) {
            const profileData = await profileResponse.json();
            verification = normalizeVerification(profileData?.user?.verification);
          }
        } catch {
          // Keep fallback verification.
        }
      }

      const photos = (tweet.media?.photos || []).map((p) => p.url).filter(Boolean);
      const videoThumbs = (tweet.media?.videos || []).map((v) => v.thumbnail_url || v.url).filter(Boolean);

      return {
        id: parsed.id,
        canonicalUrl: parsed.canonicalUrl,
        source: "fxtwitter",
        displayName: author.name || handle || "Unknown",
        handleText: handle ? `@${handle}` : "@unknown",
        verification,
        bodyRaw: (tweet.raw_text?.text || tweet.text || "").replace(/\r\n/g, "\n").trim(),
        timestampRaw: tweet.created_at || "",
        timestampLabel: formatTweetTimestamp(tweet.created_at || ""),
        metrics: {
          replies: tweet.replies ?? null,
          reposts: tweet.reposts ?? tweet.retweets ?? null,
          likes: tweet.likes ?? null,
          views: tweet.views ?? null
        },
        avatarCandidates: dedupe([author.avatar_url, ...getAvatarCandidates(handle)]),
        mediaUrls: dedupe([...photos, ...videoThumbs]).slice(0, 4)
      };
    }

    async function fetchTweetFromOembed(parsed, signal) {
      const response = await fetch(
        `https://publish.twitter.com/oembed?omit_script=1&dnt=true&url=${encodeURIComponent(parsed.canonicalUrl)}`,
        { signal }
      );

      if (!response.ok) {
        throw new Error("Could not fetch tweet via oEmbed.");
      }

      const data = await response.json();
      const parser = new DOMParser();
      const doc = parser.parseFromString(data.html || "", "text/html");
      const p = doc.querySelector("p");
      if (p) {
        p.querySelectorAll("br").forEach((br) => br.replaceWith("\n"));
      }
      const handle = (() => {
        try {
          const authorUrl = new URL(data.author_url || "");
          return authorUrl.pathname.split("/").filter(Boolean)[0] || parsed.handle || "";
        } catch {
          return parsed.handle || "";
        }
      })();

      return {
        id: parsed.id,
        canonicalUrl: parsed.canonicalUrl,
        source: "oembed",
        displayName: data.author_name || handle || "Unknown",
        handleText: handle ? `@${handle}` : "@unknown",
        verification: { verified: false, type: null },
        bodyRaw: (p?.textContent || "").replace(/\r\n/g, "\n").trim(),
        timestampRaw: "",
        timestampLabel: "",
        metrics: {
          replies: null,
          reposts: null,
          likes: null,
          views: null
        },
        avatarCandidates: getAvatarCandidates(handle),
        mediaUrls: []
      };
    }

    async function fetchAndNormalizeTweet(parsed, signal) {
      const cached = state.fetchCache.get(parsed.id);
      if (cached) {
        return cached;
      }

      let normalized;
      try {
        normalized = await fetchTweetFromFxApi(parsed, signal);
      } catch {
        normalized = await fetchTweetFromOembed(parsed, signal);
      }

      const avatarResolution = await resolveFirstImage(normalized.avatarCandidates);
      normalized.avatarUrl = avatarResolution.displayUrl;
      normalized.avatarDataUrl = avatarResolution.dataUrl;

      state.fetchCache.set(parsed.id, normalized);
      return normalized;
    }

    async function loadTweetFromInput() {
      const parsed = parseTweetUrl(el.tweetUrl.value);
      if (!parsed) {
        setStatus("Invalid tweet URL. Use a URL like https://x.com/user/status/...", "error");
        return;
      }

      state.activeToken += 1;
      const token = state.activeToken;

      if (state.abortController) {
        state.abortController.abort();
      }
      state.abortController = new AbortController();

      setLoading(true);
      setStatus("Loading tweet data...", "loading");
      if (!state.cardData) {
        showPlaceholder("Loading tweet data...", true);
      }

      try {
        const rawTweet = await fetchAndNormalizeTweet(parsed, state.abortController.signal);
        if (token !== state.activeToken) {
          return;
        }

        if (!state.rawTweet || state.rawTweet.id !== rawTweet.id) {
          state.selectedMediaIndex = 0;
          state.mediaPositions = [];
        }
        state.rawTweet = rawTweet;
        state.cardData = deriveCardData(rawTweet);
        updateSourceMeta(rawTweet);
        renderPreview();
        setStatus(rawTweet.source === "fxtwitter" ? "Loaded from FX API." : "Loaded with oEmbed fallback.", "success");
        setLoading(false);

        prefetchAssets(rawTweet);
      } catch (error) {
        if (error.name === "AbortError") {
          return;
        }
        state.rawTweet = null;
        state.cardData = null;
        setLoading(false);
        updateSourceMeta(null);
        showPlaceholder("<strong>Could not load this tweet.</strong> Check the URL and make sure the post is public.");
        setStatus(error.message || "Could not load tweet.", "error");
      }
    }

    function refreshCardFromState() {
      if (!state.rawTweet) {
        return;
      }
      state.cardData = deriveCardData(state.rawTweet);
      renderPreview();
      el.downloadBtn.disabled = false;
    }

    function onWidthInput() {
      state.width = Number(el.width.value);
      updateWidthUI();
      if (state.widthFrame) {
        cancelAnimationFrame(state.widthFrame);
      }
      state.widthFrame = requestAnimationFrame(() => {
        renderPreview();
      });
    }

    function onPasteAutoLoad() {
      setTimeout(() => {
        if (parseTweetUrl(el.tweetUrl.value)) {
          loadTweetFromInput();
        }
      }, 0);
    }

    function onMediaPointerDown(event) {
      if (!state.cardData) {
        return;
      }

      const idx = Number(event.currentTarget.dataset.mediaIndex);
      if (!Number.isFinite(idx)) {
        return;
      }

      const target = event.currentTarget;
      event.preventDefault();
      setSelectedMediaIndex(idx, false);
      document.querySelectorAll(".media-item").forEach((node) => node.classList.remove("media-item--active"));
      target.classList.add("media-item--active");

      const rect = target.getBoundingClientRect();
      const startX = event.clientX;
      const startY = event.clientY;
      const startPos = state.mediaPositions[idx] || { x: 50, y: 50 };
      const pointerId = event.pointerId;

      state.dragState = { pointerId, idx };
      if (target.setPointerCapture) {
        target.setPointerCapture(pointerId);
      }

      const onMove = (moveEvent) => {
        if (!state.dragState || moveEvent.pointerId !== pointerId) {
          return;
        }
        const dx = moveEvent.clientX - startX;
        const dy = moveEvent.clientY - startY;
        const nextX = clamp(startPos.x + (dx / Math.max(rect.width, 1)) * 100, 0, 100);
        const nextY = clamp(startPos.y + (dy / Math.max(rect.height, 1)) * 100, 0, 100);

        state.mediaPositions[idx] = { x: nextX, y: nextY };
        target.style.objectPosition = `${nextX}% ${nextY}%`;

        if (idx === state.selectedMediaIndex) {
          el.mediaPosX.value = String(Math.round(nextX));
          el.mediaPosY.value = String(Math.round(nextY));
          el.mediaPosXValue.textContent = `${Math.round(nextX)}%`;
          el.mediaPosYValue.textContent = `${Math.round(nextY)}%`;
        }
      };

      const onEnd = (endEvent) => {
        if (endEvent.pointerId !== pointerId) {
          return;
        }
        window.removeEventListener("pointermove", onMove);
        window.removeEventListener("pointerup", onEnd);
        window.removeEventListener("pointercancel", onEnd);
        state.dragState = null;
        refreshCardFromState();
      };

      window.addEventListener("pointermove", onMove);
      window.addEventListener("pointerup", onEnd);
      window.addEventListener("pointercancel", onEnd);
    }

    async function downloadPng() {
      if (!state.cardData) {
        setStatus("Load a tweet first, then download PNG.", "error");
        return;
      }

      const data = state.cardData;
      const palette = getThemePalette(data.themeMode);
      const width = state.width;
      const scale = 2;
      const padding = 28;
      const avatarSize = 44;
      const topGap = 12;
      const lineHeight = 30;
      const detailLineHeight = 22;

      const measureCanvas = document.createElement("canvas");
      const measureCtx = measureCanvas.getContext("2d");
      if (!measureCtx) {
        setStatus("Could not initialize PNG export.", "error");
        return;
      }

      measureCtx.font = "700 24px Manrope, Segoe UI, sans-serif";
      const bodyMaxWidth = width - padding * 2;
      const bodyLines = wrapTextLines(measureCtx, data.bodyText, bodyMaxWidth);
      const bodyHeight = Math.max(lineHeight, bodyLines.length * lineHeight);

      const mediaDataUrls = [];
      for (const mediaUrl of data.mediaUrls.slice(0, 4)) {
        const mediaDataUrl = await getDataUrlCached(mediaUrl);
        mediaDataUrls.push(mediaDataUrl || mediaUrl || null);
      }

      const mediaImages = [];
      for (const src of mediaDataUrls) {
        if (!src) {
          mediaImages.push(null);
          continue;
        }
        try {
          mediaImages.push(await loadImage(src));
        } catch {
          mediaImages.push(null);
        }
      }

      const mediaGap = 8;
      const mediaCount = mediaImages.length;
      let mediaHeight = 0;
      let mediaFrames = [];

      if (mediaCount === 1) {
        const cell = bodyMaxWidth;
        mediaHeight = cell;
        mediaFrames = [{ x: 0, y: 0, w: cell, h: cell }];
      } else if (mediaCount === 2) {
        const cellW = (bodyMaxWidth - mediaGap) / 2;
        const cellH = cellW;
        mediaHeight = cellH;
        mediaFrames = [
          { x: 0, y: 0, w: cellW, h: cellH },
          { x: cellW + mediaGap, y: 0, w: cellW, h: cellH }
        ];
      } else if (mediaCount === 3) {
        const cell = (bodyMaxWidth - mediaGap * 2) / 3;
        mediaHeight = cell;
        mediaFrames = [
          { x: 0, y: 0, w: cell, h: cell },
          { x: cell + mediaGap, y: 0, w: cell, h: cell },
          { x: (cell + mediaGap) * 2, y: 0, w: cell, h: cell }
        ];
      } else if (mediaCount >= 4) {
        const cellW = (bodyMaxWidth - mediaGap) / 2;
        const cellH = cellW;
        mediaHeight = cellH * 2 + mediaGap;
        mediaFrames = [
          { x: 0, y: 0, w: cellW, h: cellH },
          { x: cellW + mediaGap, y: 0, w: cellW, h: cellH },
          { x: 0, y: cellH + mediaGap, w: cellW, h: cellH },
          { x: cellW + mediaGap, y: cellH + mediaGap, w: cellW, h: cellH }
        ];
      }

      const isDetailed = data.mode === "detailed";
      const statsHeight = isDetailed ? detailLineHeight + 6 : 0;
      const timeHeight = isDetailed ? detailLineHeight + 8 : 0;

      const height = padding + avatarSize + topGap + bodyHeight + statsHeight + (mediaHeight ? mediaHeight + 12 : 0) + timeHeight + padding;

      const canvas = document.createElement("canvas");
      canvas.width = Math.round(width * scale);
      canvas.height = Math.round(height * scale);
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        setStatus("Could not initialize PNG export.", "error");
        return;
      }
      ctx.scale(scale, scale);

      ctx.fillStyle = palette.bg;
      ctx.fillRect(0, 0, width, height);

      const avatarSrc = data.avatarDataUrl || (await getDataUrlCached(data.avatarUrl)) || data.avatarUrl;
      try {
        const avatarImage = await loadImage(avatarSrc);
        ctx.save();
        ctx.beginPath();
        ctx.arc(padding + avatarSize / 2, padding + avatarSize / 2, avatarSize / 2, 0, Math.PI * 2);
        ctx.closePath();
        ctx.clip();
        ctx.drawImage(avatarImage, padding, padding, avatarSize, avatarSize);
        ctx.restore();
      } catch {
        ctx.fillStyle = palette.avatarBg;
        ctx.beginPath();
        ctx.arc(padding + avatarSize / 2, padding + avatarSize / 2, avatarSize / 2, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = palette.text;
      ctx.font = "700 24px Manrope, Segoe UI, sans-serif";
      const nameX = padding + avatarSize + 12;
      const nameY = padding + 24;
      const nameText = data.displayName || data.handleText;
      ctx.fillText(nameText, nameX, nameY);
      const nameWidth = ctx.measureText(nameText).width;
      const afterBadgeX = drawVerifyBadge(ctx, nameX + nameWidth + 8, padding + 8, data.verification);

      ctx.fillStyle = palette.muted;
      ctx.font = "500 20px Manrope, Segoe UI, sans-serif";
      ctx.fillText(data.handleText, afterBadgeX + 6, padding + 24);

      ctx.fillStyle = palette.text;
      ctx.font = "500 24px Manrope, Segoe UI, sans-serif";
      let y = padding + avatarSize + topGap + 24;
      for (const line of bodyLines) {
        ctx.fillText(line, padding, y);
        y += lineHeight;
      }

      if (isDetailed) {
        ctx.fillStyle = palette.muted;
        ctx.font = "500 19px Manrope, Segoe UI, sans-serif";
        ctx.fillText(
          `${formatMetric(data.metrics.replies)} Replies   ` +
          `${formatMetric(data.metrics.reposts)} Reposts   ` +
          `${formatMetric(data.metrics.likes)} Likes   ` +
          `${formatMetric(data.metrics.views)} Views`,
          padding,
          y + 2
        );
        y += statsHeight;
      }

      if (mediaHeight > 0) {
        const mediaX = padding;
        const mediaY = y + 4;
        const radius = 12;

        const drawRoundedMedia = (img, mediaPos, x, yy, w, h) => {
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(x + radius, yy);
          ctx.lineTo(x + w - radius, yy);
          ctx.quadraticCurveTo(x + w, yy, x + w, yy + radius);
          ctx.lineTo(x + w, yy + h - radius);
          ctx.quadraticCurveTo(x + w, yy + h, x + w - radius, yy + h);
          ctx.lineTo(x + radius, yy + h);
          ctx.quadraticCurveTo(x, yy + h, x, yy + h - radius);
          ctx.lineTo(x, yy + radius);
          ctx.quadraticCurveTo(x, yy, x + radius, yy);
          ctx.closePath();
          ctx.clip();

          if (img && drawCoverImage(ctx, img, x, yy, w, h, mediaPos)) {
            // Drawn above.
          } else {
            ctx.fillStyle = palette.mediaBg;
            ctx.fillRect(x, yy, w, h);
          }

          ctx.restore();
        };

        mediaFrames.forEach((frame, i) => {
          const mediaPos = data.mediaPositions?.[i] || { x: 50, y: 50 };
          drawRoundedMedia(
            mediaImages[i] || null,
            mediaPos,
            mediaX + frame.x,
            mediaY + frame.y,
            frame.w,
            frame.h
          );
        });

        y += mediaHeight + 12;
      }

      if (isDetailed) {
        ctx.fillStyle = palette.muted;
        ctx.font = "500 19px Manrope, Segoe UI, sans-serif";
        ctx.fillText(data.timestampLabel || "Date unavailable", padding, y + 2);
      }

      let pngUrl = "";
      try {
        pngUrl = canvas.toDataURL("image/png");
      } catch {
        setStatus("PNG export failed due browser image security restrictions.", "error");
        return;
      }

      const link = document.createElement("a");
      link.href = pngUrl;
      link.download = `tweet-card-${Date.now()}.png`;
      link.click();
      setStatus("PNG downloaded.", "success");
    }

    function bindEvents() {
      el.tweetUrl.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          loadTweetFromInput();
        }
      });

      el.tweetUrl.addEventListener("paste", onPasteAutoLoad);

      el.viewMode.addEventListener("change", () => {
        state.viewMode = el.viewMode.value;
        refreshCardFromState();
      });

      el.themeMode.addEventListener("change", () => {
        state.themeMode = el.themeMode.value;
        refreshCardFromState();
      });

      el.stripReplyMentions.addEventListener("change", () => {
        state.stripReplyMentions = el.stripReplyMentions.checked;
        refreshCardFromState();
      });

      el.mediaIndex.addEventListener("change", () => {
        setSelectedMediaIndex(Number(el.mediaIndex.value) || 0);
      });

      el.mediaPosX.addEventListener("input", () => {
        applySelectedMediaPosition(Number(el.mediaPosX.value), Number(el.mediaPosY.value), false);
      });

      el.mediaPosY.addEventListener("input", () => {
        applySelectedMediaPosition(Number(el.mediaPosX.value), Number(el.mediaPosY.value), false);
      });

      el.mediaPosX.addEventListener("change", refreshCardFromState);
      el.mediaPosY.addEventListener("change", refreshCardFromState);

      el.width.addEventListener("input", onWidthInput);

      el.downloadBtn.addEventListener("click", downloadPng);
    }

    function init() {
      state.width = Number(el.width.value);
      state.viewMode = el.viewMode.value;
      state.themeMode = el.themeMode.value;
      state.stripReplyMentions = el.stripReplyMentions.checked;
      updateWidthUI();
      bindEvents();
    }

    init();
  </script>
</body>

</html>
